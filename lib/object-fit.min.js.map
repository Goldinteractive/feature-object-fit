{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///object-fit.min.js","webpack:///webpack/bootstrap 4592a2284bb342274ce8","webpack:///./~/iphone-inline-video/dist/iphone-inline-video.es-modules.js","webpack:///./~/object-fit-images/dist/ofi.es-modules.js","webpack:///./~/object-fit-videos/object-fit-videos.js","webpack:///./~/intervalometer/dist/intervalometer.es-modules.js","webpack:///./src/index.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","preventEvent","element","eventName","toggleProperty","preventWithProperty","handler","e","Boolean","stopImmediatePropagation","addEventListener","proxyProperty","propertyName","sourceObject","copyFirst","set","proxyEvent","dispatchEvent","Event","dispatchEventAsync","type","Promise","resolve","then","getAudioFromVideo","video","audio","Audio","crossOrigin","src","currentSrc","setTime","time","rememberOnly","lastTimeupdateEvent","Date","now","ಠevent","currentTime","lastRequests","requestIndex","isPlayerEnded","player","driver","duration","update","timeDiff","readyState","HAVE_FUTURE_DATA","hasAudio","playbackRate","loop","networkState","NETWORK_IDLE","buffered","length","load","ended","pause","play","ಠ","webkitDisplayingFullscreen","ಠplay","paused","updater","start","HAVE_ENOUGH_DATA","forceEvents","stop","ಠpause","addPlayer","__WEBPACK_IMPORTED_MODULE_0_intervalometer__","bind","muted","wasEmpty","indexOf","overloadAPI","enableInlineVideo","opts","everywhere","iOS8or9","iPad","ipad","test","navigator","userAgent","classList","add","autoplay","platform","console","warn","document","head","style","matchMedia","matches","createPlaceholder","w","h","polyfillCurrentSrc","el","srcset","supportsCurrentSrc","window","picturefill","pf","_","ns","evaled","fillImg","reselect","curSrc","supported","getStyle","getComputedStyle","fontFamily","parsed","props","propRegex","exec","setPlaceholder","img","width","height","placeholder","nativeGetAttribute","nativeSetAttribute","onImageReady","callback","naturalWidth","setTimeout","fixOne","ofi","OFI","skipTest","supportsObjectFit","Image","naturalHeight","keepSrcUsable","err","log","backgroundImage","replace","backgroundPosition","backgroundRepeat","backgroundSize","descriptors","prop","ss","hijackAttributes","getOfiImageMaybe","supportsObjectPosition","HTMLImageElement","getAttribute","setAttribute","String","fix","imgs","startAutoMode","autoModeEnabled","supportsOFI","querySelectorAll","body","target","tagName","watchMQ","testImg","objectFitVideos","videos","$el","parsePosition","initialize","index","fitIt","doWork","videoWidth","videoHeight","videoRatio","wrapWidth","$wrap","clientWidth","wrapHeight","clientHeight","wrapRatio","newHeight","newWidth","setCss","marginLeft","marginTop","Math","round","getCss","createElement","appendChild","parentNode","replaceChild","wrapCss","boxSizing","display","overflow","key","border","margin","padding","opacity","removeEventListener","throttle","obj","running","evt","CustomEvent","createEvent","initEvent","func","requestAnimationFrame","intervalometer","cb","request","cancel","requestParameter","requestId","previousLoopTime","frameIntervalometer","cancelAnimationFrame","timerIntervalometer","delay","clearTimeout","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","mod","apply","undefined","_objectFitImages","_objectFitVideos","_iphoneInlineVideo","_interopRequireDefault","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_objectFitImages2","_objectFitVideos2","_iphoneInlineVideo2","_createClass","defineProperties","descriptor","protoProps","staticProps","CLASS_FEATURE","CLASS_INITIAL_HIDE","ObjectFit","_base$features$Featur","getPrototypeOf","arguments","init","_this2","_objectFit","node","_objectPosition","objectFit","objectPosition","options","defaultObjectPosition","defaultObjectFit","nodeName","toLowerCase","base","utils","fn","rAF","parentElement","visibility","closest","remove","features","Feature","defaultOptions"],"mappings":"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","file":"object-fit.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"object-fit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"object-fit\"] = factory();\n\telse\n\t\troot[\"object-fit\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"object-fit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"object-fit\"] = factory();\n\telse\n\t\troot[\"object-fit\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_intervalometer__ = __webpack_require__(3);\n/*! npm.im/iphone-inline-video 2.0.2 */\n\n\nfunction preventEvent(element, eventName, toggleProperty, preventWithProperty) {\n\tfunction handler(e) {\n\t\tif (Boolean(element[toggleProperty]) === Boolean(preventWithProperty)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// console.log(eventName, 'prevented on', element);\n\t\t}\n\t\tdelete element[toggleProperty];\n\t}\n\telement.addEventListener(eventName, handler, false);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar ಠ = 'bfred-it:iphone-inline-video';\nvar ಠevent = 'bfred-it:iphone-inline-video:event';\nvar ಠplay = 'bfred-it:iphone-inline-video:nativeplay';\nvar ಠpause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[ಠevent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n\t\t// this should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// console.log('Will load');\n\t}\n\n\t// console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[ಠevent]; // allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// console.log('play');\n\tvar video = this;\n\tvar player = video[ಠ];\n\n\t// if it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[ಠplay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (video.buffered.length === 0) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// console.log('pause');\n\tvar video = this;\n\tvar player = video[ಠ];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// if it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[ಠpause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\tif (video.ended) {\n\t\tvideo[ಠevent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = video[ಠ] = {};\n\tplayer.paused = true; // track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_intervalometer__[\"a\" /* frameIntervalometer */])(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// playing videos will only keep playing if no src was present when .play()’ed\n\t\t\tif (wasEmpty) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// play video natively\n\t\t\tvideo[ಠplay]();\n\t\t} else if (hasAudio && player.driver.buffered.length === 0) {\n\t\t\t// if the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[ಠ];\n\tvideo[ಠplay] = video.play;\n\tvideo[ಠpause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\tpreventEvent(video, 'seeking');\n\tpreventEvent(video, 'seeked');\n\tpreventEvent(video, 'timeupdate', ಠevent, false);\n\tpreventEvent(video, 'ended', ಠevent, false); // prevent occasional native ended events\n}\n\nfunction enableInlineVideo(video, opts) {\n\tif ( opts === void 0 ) opts = {};\n\n\t// Stop if already enabled\n\tif (video[ಠ]) {\n\t\treturn;\n\t}\n\n\t// Allow the user to skip detection\n\tif (!opts.everywhere) {\n\t\t// Only iOS8 and 9 are supported\n\t\tif (!iOS8or9) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop if it's not an allowed device\n\t\tif (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Stop native playback\n\tif (!video.paused && video.webkitDisplayingFullscreen) {\n\t\tvideo.pause();\n\t}\n\n\taddPlayer(video, !video.muted);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\n\t// Autoplay\n\tif (video.muted && video.autoplay) {\n\t\tvideo.play();\n\t}\n\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = enableInlineVideo;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/*! npm.im/object-fit-images */\nvar OFI = 'bfred-it:object-fit-images';\nvar propRegex = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\nvar testImg = new Image();\nvar supportsObjectFit = 'object-fit' in testImg.style;\nvar supportsObjectPosition = 'object-position' in testImg.style;\nvar supportsOFI = 'background-size' in testImg.style;\nvar supportsCurrentSrc = typeof testImg.currentSrc === 'string';\nvar nativeGetAttribute = testImg.getAttribute;\nvar nativeSetAttribute = testImg.setAttribute;\nvar autoModeEnabled = false;\n\nfunction createPlaceholder(w, h) {\n\treturn (\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='\" + w + \"' height='\" + h + \"'%3E%3C/svg%3E\");\n}\n\nfunction polyfillCurrentSrc(el) {\n\tif (el.srcset && !supportsCurrentSrc && window.picturefill) {\n\t\tvar pf = window.picturefill._;\n\t\t// parse srcset with picturefill where currentSrc isn't available\n\t\tif (!el[pf.ns] || !el[pf.ns].evaled) {\n\t\t\t// force synchronous srcset parsing\n\t\t\tpf.fillImg(el, {reselect: true});\n\t\t}\n\n\t\tif (!el[pf.ns].curSrc) {\n\t\t\t// force picturefill to parse srcset\n\t\t\tel[pf.ns].supported = false;\n\t\t\tpf.fillImg(el, {reselect: true});\n\t\t}\n\n\t\t// retrieve parsed currentSrc, if any\n\t\tel.currentSrc = el[pf.ns].curSrc || el.src;\n\t}\n}\n\nfunction getStyle(el) {\n\tvar style = getComputedStyle(el).fontFamily;\n\tvar parsed;\n\tvar props = {};\n\twhile ((parsed = propRegex.exec(style)) !== null) {\n\t\tprops[parsed[1]] = parsed[2];\n\t}\n\treturn props;\n}\n\nfunction setPlaceholder(img, width, height) {\n\t// Default: fill width, no height\n\tvar placeholder = createPlaceholder(width || 1, height || 0);\n\n\t// Only set placeholder if it's different\n\tif (nativeGetAttribute.call(img, 'src') !== placeholder) {\n\t\tnativeSetAttribute.call(img, 'src', placeholder);\n\t}\n}\n\nfunction onImageReady(img, callback) {\n\t// naturalWidth is only available when the image headers are loaded,\n\t// this loop will poll it every 100ms.\n\tif (img.naturalWidth) {\n\t\tcallback(img);\n\t} else {\n\t\tsetTimeout(onImageReady, 100, img, callback);\n\t}\n}\n\nfunction fixOne(el) {\n\tvar style = getStyle(el);\n\tvar ofi = el[OFI];\n\tstyle['object-fit'] = style['object-fit'] || 'fill'; // default value\n\n\t// Avoid running where unnecessary, unless OFI had already done its deed\n\tif (!ofi.img) {\n\t\t// fill is the default behavior so no action is necessary\n\t\tif (style['object-fit'] === 'fill') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Where object-fit is supported and object-position isn't (Safari < 10)\n\t\tif (\n\t\t\t!ofi.skipTest && // unless user wants to apply regardless of browser support\n\t\t\tsupportsObjectFit && // if browser already supports object-fit\n\t\t\t!style['object-position'] // unless object-position is used\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// keep a clone in memory while resetting the original to a blank\n\tif (!ofi.img) {\n\t\tofi.img = new Image(el.width, el.height);\n\t\tofi.img.srcset = nativeGetAttribute.call(el, \"data-ofi-srcset\") || el.srcset;\n\t\tofi.img.src = nativeGetAttribute.call(el, \"data-ofi-src\") || el.src;\n\n\t\t// preserve for any future cloneNode calls\n\t\t// https://github.com/bfred-it/object-fit-images/issues/53\n\t\tnativeSetAttribute.call(el, \"data-ofi-src\", el.src);\n\t\tif (el.srcset) {\n\t\t\tnativeSetAttribute.call(el, \"data-ofi-srcset\", el.srcset);\n\t\t}\n\n\t\tsetPlaceholder(el, el.naturalWidth || el.width, el.naturalHeight || el.height);\n\n\t\t// remove srcset because it overrides src\n\t\tif (el.srcset) {\n\t\t\tel.srcset = '';\n\t\t}\n\t\ttry {\n\t\t\tkeepSrcUsable(el);\n\t\t} catch (err) {\n\t\t\tif (window.console) {\n\t\t\t\tconsole.log('http://bit.ly/ofi-old-browser');\n\t\t\t}\n\t\t}\n\t}\n\n\tpolyfillCurrentSrc(ofi.img);\n\n\tel.style.backgroundImage = \"url(\" + ((ofi.img.currentSrc || ofi.img.src).replace('(', '%28').replace(')', '%29')) + \")\";\n\tel.style.backgroundPosition = style['object-position'] || 'center';\n\tel.style.backgroundRepeat = 'no-repeat';\n\n\tif (/scale-down/.test(style['object-fit'])) {\n\t\tonImageReady(ofi.img, function () {\n\t\t\tif (ofi.img.naturalWidth > el.width || ofi.img.naturalHeight > el.height) {\n\t\t\t\tel.style.backgroundSize = 'contain';\n\t\t\t} else {\n\t\t\t\tel.style.backgroundSize = 'auto';\n\t\t\t}\n\t\t});\n\t} else {\n\t\tel.style.backgroundSize = style['object-fit'].replace('none', 'auto').replace('fill', '100% 100%');\n\t}\n\n\tonImageReady(ofi.img, function (img) {\n\t\tsetPlaceholder(el, img.naturalWidth, img.naturalHeight);\n\t});\n}\n\nfunction keepSrcUsable(el) {\n\tvar descriptors = {\n\t\tget: function get(prop) {\n\t\t\treturn el[OFI].img[prop ? prop : 'src'];\n\t\t},\n\t\tset: function set(value, prop) {\n\t\t\tel[OFI].img[prop ? prop : 'src'] = value;\n\t\t\tnativeSetAttribute.call(el, (\"data-ofi-\" + prop), value); // preserve for any future cloneNode\n\t\t\tfixOne(el);\n\t\t\treturn value;\n\t\t}\n\t};\n\tObject.defineProperty(el, 'src', descriptors);\n\tObject.defineProperty(el, 'currentSrc', {\n\t\tget: function () { return descriptors.get('currentSrc'); }\n\t});\n\tObject.defineProperty(el, 'srcset', {\n\t\tget: function () { return descriptors.get('srcset'); },\n\t\tset: function (ss) { return descriptors.set(ss, 'srcset'); }\n\t});\n}\n\nfunction hijackAttributes() {\n\tfunction getOfiImageMaybe(el, name) {\n\t\treturn el[OFI] && el[OFI].img && (name === 'src' || name === 'srcset') ? el[OFI].img : el;\n\t}\n\tif (!supportsObjectPosition) {\n\t\tHTMLImageElement.prototype.getAttribute = function (name) {\n\t\t\treturn nativeGetAttribute.call(getOfiImageMaybe(this, name), name);\n\t\t};\n\n\t\tHTMLImageElement.prototype.setAttribute = function (name, value) {\n\t\t\treturn nativeSetAttribute.call(getOfiImageMaybe(this, name), name, String(value));\n\t\t};\n\t}\n}\n\nfunction fix(imgs, opts) {\n\tvar startAutoMode = !autoModeEnabled && !imgs;\n\topts = opts || {};\n\timgs = imgs || 'img';\n\n\tif ((supportsObjectPosition && !opts.skipTest) || !supportsOFI) {\n\t\treturn false;\n\t}\n\n\t// use imgs as a selector or just select all images\n\tif (typeof imgs === 'string') {\n\t\timgs = document.querySelectorAll(imgs);\n\t} else if (!('length' in imgs)) {\n\t\timgs = [imgs];\n\t}\n\n\t// apply fix to all\n\tfor (var i = 0; i < imgs.length; i++) {\n\t\timgs[i][OFI] = imgs[i][OFI] || {\n\t\t\tskipTest: opts.skipTest\n\t\t};\n\t\tfixOne(imgs[i]);\n\t}\n\n\tif (startAutoMode) {\n\t\tdocument.body.addEventListener('load', function (e) {\n\t\t\tif (e.target.tagName === 'IMG') {\n\t\t\t\tfix(e.target, {\n\t\t\t\t\tskipTest: opts.skipTest\n\t\t\t\t});\n\t\t\t}\n\t\t}, true);\n\t\tautoModeEnabled = true;\n\t\timgs = 'img'; // reset to a generic selector for watchMQ\n\t}\n\n\t// if requested, watch media queries for object-fit change\n\tif (opts.watchMQ) {\n\t\twindow.addEventListener('resize', fix.bind(null, imgs, {\n\t\t\tskipTest: opts.skipTest\n\t\t}));\n\t}\n}\n\nfix.supportsObjectFit = supportsObjectFit;\nfix.supportsObjectPosition = supportsObjectPosition;\n\nhijackAttributes();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = fix;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n * Object Fit Videos\n * Polyfill for object-fit and object-position CSS properties on video elements\n * Covers IE9, IE10, IE11, Edge, Safari <10\n *\n * Usage\n * In your CSS, add a special font-family tag for IE/Edge\n * video {\n *   object-fit: cover;\n *   font-family: 'object-fit: cover;';\n * }\n *\n * Before the closing body tag, or whenever the DOM is ready,\n * make the JavaScript call\n * objectFitVideos();\n *\n * All video elements with the special CSS property will be targeted\n *\n * @license  MIT (https://opensource.org/licenses/MIT)\n * @author   Todd Miller <todd.miller@tricomb2b.com>\n * @version  1.0.2\n * @changelog\n * 2016-08-19 - Adds object-position support.\n * 2016-08-19 - Add throttle function for more performant resize events\n * 2016-08-19 - Initial release with object-fit support, and\n *              object-position default 'center'\n * 2016-10-14 - No longer relies on window load event, instead requires a specific\n *              function call to initialize the videos for object fit and position.\n * 2016-11-28 - Support CommonJS environment, courtesy of @msorensson\n * 2016-12-05 - Refactors the throttling function to support IE\n */\nvar objectFitVideos = function (videos) {\n  'use strict';\n\n  var testImg                = new Image(),\n      supportsObjectFit      = 'object-fit' in testImg.style,\n      supportsObjectPosition = 'object-position' in testImg.style,\n      propRegex              = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\n\n  if (!supportsObjectFit || !supportsObjectPosition) {\n    initialize(videos);\n    throttle('resize', 'optimizedResize');\n  }\n\n  /**\n   * Parse the style and look for the special font-family tag\n   * @param  {object} $el The element to parse\n   * @return {object}     The font-family properties we're interested in\n   */\n  function getStyle ($el) {\n    var style  = getComputedStyle($el).fontFamily,\n        parsed = null,\n        props  = {};\n\n      while ((parsed = propRegex.exec(style)) !== null) {\n        props[parsed[1]] = parsed[2];\n      }\n\n      if (props['object-position'])\n        return parsePosition(props);\n\n      return props;\n  }\n\n  /**\n   * Initialize all the relevant video elements and get them fitted\n   */\n  function initialize (videos) {\n    var index  = -1;\n    videos = videos || 'video';\n\n    // use videos as a selector or just select all videos\n    if (typeof videos === 'string') {\n      videos = document.querySelectorAll(videos);\n    } else if (!('length' in videos)) {\n      videos = [videos];\n    }\n\n    while (videos[++index]) {\n      var style = getStyle(videos[index]);\n\n      // only do work if the property is on the element\n      if (style['object-fit'] || style['object-position']) {\n        // set the default values\n        style['object-fit'] = style['object-fit'] || 'fill';\n        fitIt(videos[index], style);\n      }\n    }\n  }\n\n  /**\n   * Object Fit\n   * @param  {object} $el Element to fit\n   * @return {object}     The element's relevant properties\n   */\n  function fitIt ($el, style) {\n    // fill is the default behavior, no action is necessary\n    if (style['object-fit'] === 'fill')\n      return;\n\n    // convenience style properties on the source element\n    var setCss = $el.style,\n        getCss = window.getComputedStyle($el);\n\n    // create and insert a wrapper element\n    var $wrap = document.createElement('object-fit');\n    $wrap.appendChild($el.parentNode.replaceChild($wrap, $el));\n\n    // style the wrapper element to mostly match the source element\n    var wrapCss = {\n      height:    '100%',\n      width:     '100%',\n      boxSizing: 'content-box',\n      display:   'inline-block',\n      overflow:  'hidden'\n    };\n\n    'backgroundColor backgroundImage borderColor borderStyle borderWidth bottom fontSize lineHeight left opacity margin position right top visibility'.replace(/\\w+/g, function (key) {\n      wrapCss[key] = getCss[key];\n    });\n\n    for (var key in wrapCss)\n      $wrap.style[key] = wrapCss[key];\n\n    // give the source element some saner styles\n    setCss.border  = setCss.margin = setCss.padding = 0;\n    setCss.display = 'block';\n    setCss.opacity = 1;\n\n    // set up the event handlers\n    $el.addEventListener('loadedmetadata', doWork);\n    window.addEventListener('optimizedResize', doWork);\n\n    // we may have missed the loadedmetadata event, so if the video has loaded\n    // enough data, just drop the event listener and execute\n    if ($el.readyState >= 1) {\n      $el.removeEventListener('loadedmetadata', doWork);\n      doWork();\n    }\n\n    /**\n     * Do the actual sizing. Math.\n     * @methodOf fitIt\n     */\n    function doWork () {\n      // the actual size and ratio of the video\n      // we do this here, even though it doesn't change, because\n      // at this point we can be sure the metadata has loaded\n      var videoWidth  = $el.videoWidth,\n          videoHeight = $el.videoHeight,\n          videoRatio  = videoWidth / videoHeight;\n\n      var wrapWidth  = $wrap.clientWidth,\n          wrapHeight = $wrap.clientHeight,\n          wrapRatio  = wrapWidth / wrapHeight;\n\n      var newHeight = 0,\n          newWidth  = 0;\n      setCss.marginLeft = setCss.marginTop = 0;\n\n      // basically we do the opposite action for contain and cover,\n      // depending on whether the video aspect ratio is less than or\n      // greater than the wrapper's aspect ratio\n      if (videoRatio < wrapRatio ?\n          style['object-fit'] === 'contain' : style['object-fit'] === 'cover') {\n        newHeight = wrapHeight * videoRatio;\n        newWidth  = wrapWidth / videoRatio;\n\n        setCss.width  = Math.round(newHeight) + 'px';\n        setCss.height = wrapHeight + 'px';\n\n        if (style['object-position-x'] === 'left')\n          setCss.marginLeft = 0;\n        else if (style['object-position-x'] === 'right')\n          setCss.marginLeft = Math.round(wrapWidth - newHeight) + 'px';\n        else\n          setCss.marginLeft = Math.round((wrapWidth - newHeight) / 2) + 'px';\n      } else {\n        newWidth = wrapWidth / videoRatio;\n\n        setCss.width     = wrapWidth + 'px';\n        setCss.height    = Math.round(newWidth) + 'px';\n\n        if (style['object-position-y'] === 'top')\n          setCss.marginTop = 0;\n        else if (style['object-position-y'] === 'bottom')\n          setCss.marginTop = Math.round(wrapHeight - newWidth) + 'px';\n        else\n          setCss.marginTop = Math.round((wrapHeight - newWidth) / 2) + 'px';\n      }\n    }\n  }\n\n  /**\n   * Split the object-position property into x and y position properties\n   * @param  {object} style Relevant element styles\n   * @return {object}       The style object with the added x and y props\n   */\n  function parsePosition (style) {\n    if (~style['object-position'].indexOf('left'))\n      style['object-position-x'] = 'left';\n    else if (~style['object-position'].indexOf('right'))\n      style['object-position-x'] = 'right';\n    else\n      style['object-position-x'] = 'center';\n\n    if (~style['object-position'].indexOf('top'))\n      style['object-position-y'] = 'top';\n    else if (~style['object-position'].indexOf('bottom'))\n      style['object-position-y'] = 'bottom';\n    else\n      style['object-position-y'] = 'center';\n\n    return style;\n  }\n\n  /**\n   * Throttle an event with RequestAnimationFrame API for better performance\n   * @param  {string} type The event to throttle\n   * @param  {string} name Custom event name to listen for\n   * @param  {object} obj  Optional object to attach the event to\n   */\n  function throttle (type, name, obj) {\n    obj = obj || window;\n    var running = false,\n        evt     = null;\n\n    // IE does not support the CustomEvent constructor\n    // so if that fails do it the old way\n    try {\n      evt = new CustomEvent(name);\n    } catch (e) {\n      evt = document.createEvent('Event');\n      evt.initEvent(name, true, true);\n    }\n\n    var func = function () {\n      if (running) return;\n\n      running = true;\n      requestAnimationFrame(function () {\n        obj.dispatchEvent(evt);\n        running = false;\n      });\n    };\n\n    obj.addEventListener(type, func);\n  }\n};\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\n  module.exports = objectFitVideos;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export intervalometer */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return frameIntervalometer; });\n/* unused harmony export timerIntervalometer */\n/*! npm.im/intervalometer */\nfunction intervalometer(cb, request, cancel, requestParameter) {\n\tvar requestId;\n\tvar previousLoopTime;\n\tfunction loop(now) {\n\t\t// must be requested before cb() because that might call .stop()\n\t\trequestId = request(loop, requestParameter);\n\n\t\t// called with \"ms since last call\". 0 on start()\n\t\tcb(now - (previousLoopTime || now));\n\n\t\tpreviousLoopTime = now;\n\t}\n\treturn {\n\t\tstart: function start() {\n\t\t\tif (!requestId) { // prevent double starts\n\t\t\t\tloop(0);\n\t\t\t}\n\t\t},\n\t\tstop: function stop() {\n\t\t\tcancel(requestId);\n\t\t\trequestId = null;\n\t\t\tpreviousLoopTime = 0;\n\t\t}\n\t};\n}\n\nfunction frameIntervalometer(cb) {\n\treturn intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);\n}\n\nfunction timerIntervalometer(cb, delay) {\n\treturn intervalometer(cb, setTimeout, clearTimeout, delay);\n}\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('object-fit-images'), require('object-fit-videos'), require('iphone-inline-video'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.objectFitImages, global.objectFitVideos, global.iphoneInlineVideo);\n    global.index = mod.exports;\n  }\n})(this, function (exports, _objectFitImages, _objectFitVideos, _iphoneInlineVideo) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _objectFitImages2 = _interopRequireDefault(_objectFitImages);\n\n  var _objectFitVideos2 = _interopRequireDefault(_objectFitVideos);\n\n  var _iphoneInlineVideo2 = _interopRequireDefault(_iphoneInlineVideo);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var CLASS_FEATURE = '.ft-fit-bg';\n  var CLASS_INITIAL_HIDE = '-initial-hide';\n\n  /**\n   * Object fit feature class.\n   */\n\n  var ObjectFit = function (_base$features$Featur) {\n    _inherits(ObjectFit, _base$features$Featur);\n\n    function ObjectFit() {\n      _classCallCheck(this, ObjectFit);\n\n      return _possibleConstructorReturn(this, (ObjectFit.__proto__ || Object.getPrototypeOf(ObjectFit)).apply(this, arguments));\n    }\n\n    _createClass(ObjectFit, [{\n      key: 'init',\n      value: function init() {\n        var _this2 = this;\n\n        this._objectFit = this.node.getAttribute('data-object-fit');\n        this._objectPosition = this.node.getAttribute('data-object-position');\n\n        if (this._objectFit && this._objectPosition) {\n          this.node.style.objectFit = this._objectFit;\n          this.node.style.objectPosition = this._objectPosition;\n          this.node.style.fontFamily = '\"object-fit: ' + this._objectFit + '; object-position: ' + this._objectPosition + '\"';\n        } else if (this._objectFit) {\n          this.node.style.objectFit = this._objectFit;\n          this.node.style.fontFamily = '\"object-fit: ' + this._objectFit + '; object-position: ' + this.options.defaultObjectPosition + '\"';\n        } else if (this._objectPosition) {\n          this.node.style.objectPosition = this._objectPosition;\n          this.node.style.fontFamily = '\"object-fit: ' + this.options.defaultObjectFit + '; object-position: ' + this._objectPosition + '\"';\n        }\n\n        if (this.node.nodeName.toLowerCase() == 'video') {\n          (0, _objectFitVideos2.default)(this.node);\n          (0, _iphoneInlineVideo2.default)(this.node, {\n            iPad: this.options.iPad\n          });\n\n          if (this.node.autoplay) this.node.play();\n        } else {\n          (0, _objectFitImages2.default)(this.node, {\n            watchMQ: this.options.watchMQ\n          });\n        }\n\n        // remove initial hide class\n        base.utils.fn.rAF(function () {\n          if (_this2.node.parentElement.tagName.toLowerCase() === 'object-fit') {\n            _this2.node.parentElement.style.visibility = 'visible';\n          }\n\n          _this2.node.closest(CLASS_FEATURE).classList.remove(CLASS_INITIAL_HIDE);\n        });\n      }\n    }]);\n\n    return ObjectFit;\n  }(base.features.Feature);\n\n  /**\n   * Default feature options (also used to initialize object-fit-images and iphone-inline-video library).\n   *\n   * @see https://github.com/bfred-it/object-fit-images\n   *\n   * @type {Object}\n   * @property {Boolean} watchMQ=false\n   *   This enables the automatic re-fix of the selected images when the window resizes.\n   *   You only need it in some cases\n   * @property {String} defaultObjectFit='cover'\n   *   Default object fit used when only `data-object-position` is defined\n   * @property {String} defaultObjectPosition='center center'\n   *   Default object position used when only `data-object-fit` is defined\n   */\n  ObjectFit.defaultOptions = {\n    iPad: true,\n    watchMQ: false,\n    defaultObjectFit: 'cover',\n    defaultObjectPosition: 'center center'\n  };\n\n  exports.default = ObjectFit;\n});\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// object-fit.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4592a2284bb342274ce8","/*! npm.im/iphone-inline-video 2.0.2 */\nimport { frameIntervalometer } from 'intervalometer';\n\nfunction preventEvent(element, eventName, toggleProperty, preventWithProperty) {\n\tfunction handler(e) {\n\t\tif (Boolean(element[toggleProperty]) === Boolean(preventWithProperty)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// console.log(eventName, 'prevented on', element);\n\t\t}\n\t\tdelete element[toggleProperty];\n\t}\n\telement.addEventListener(eventName, handler, false);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar ಠ = 'bfred-it:iphone-inline-video';\nvar ಠevent = 'bfred-it:iphone-inline-video:event';\nvar ಠplay = 'bfred-it:iphone-inline-video:nativeplay';\nvar ಠpause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[ಠevent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n\t\t// this should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// console.log('Will load');\n\t}\n\n\t// console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[ಠevent]; // allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// console.log('play');\n\tvar video = this;\n\tvar player = video[ಠ];\n\n\t// if it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[ಠplay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (video.buffered.length === 0) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// console.log('pause');\n\tvar video = this;\n\tvar player = video[ಠ];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// if it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[ಠpause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\tif (video.ended) {\n\t\tvideo[ಠevent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = video[ಠ] = {};\n\tplayer.paused = true; // track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = frameIntervalometer(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// playing videos will only keep playing if no src was present when .play()’ed\n\t\t\tif (wasEmpty) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// play video natively\n\t\t\tvideo[ಠplay]();\n\t\t} else if (hasAudio && player.driver.buffered.length === 0) {\n\t\t\t// if the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[ಠ];\n\tvideo[ಠplay] = video.play;\n\tvideo[ಠpause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\tpreventEvent(video, 'seeking');\n\tpreventEvent(video, 'seeked');\n\tpreventEvent(video, 'timeupdate', ಠevent, false);\n\tpreventEvent(video, 'ended', ಠevent, false); // prevent occasional native ended events\n}\n\nfunction enableInlineVideo(video, opts) {\n\tif ( opts === void 0 ) opts = {};\n\n\t// Stop if already enabled\n\tif (video[ಠ]) {\n\t\treturn;\n\t}\n\n\t// Allow the user to skip detection\n\tif (!opts.everywhere) {\n\t\t// Only iOS8 and 9 are supported\n\t\tif (!iOS8or9) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop if it's not an allowed device\n\t\tif (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Stop native playback\n\tif (!video.paused && video.webkitDisplayingFullscreen) {\n\t\tvideo.pause();\n\t}\n\n\taddPlayer(video, !video.muted);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\n\t// Autoplay\n\tif (video.muted && video.autoplay) {\n\t\tvideo.play();\n\t}\n\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\nexport default enableInlineVideo;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/iphone-inline-video/dist/iphone-inline-video.es-modules.js\n// module id = 0\n// module chunks = 0","/*! npm.im/object-fit-images */\nvar OFI = 'bfred-it:object-fit-images';\nvar propRegex = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\nvar testImg = new Image();\nvar supportsObjectFit = 'object-fit' in testImg.style;\nvar supportsObjectPosition = 'object-position' in testImg.style;\nvar supportsOFI = 'background-size' in testImg.style;\nvar supportsCurrentSrc = typeof testImg.currentSrc === 'string';\nvar nativeGetAttribute = testImg.getAttribute;\nvar nativeSetAttribute = testImg.setAttribute;\nvar autoModeEnabled = false;\n\nfunction createPlaceholder(w, h) {\n\treturn (\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='\" + w + \"' height='\" + h + \"'%3E%3C/svg%3E\");\n}\n\nfunction polyfillCurrentSrc(el) {\n\tif (el.srcset && !supportsCurrentSrc && window.picturefill) {\n\t\tvar pf = window.picturefill._;\n\t\t// parse srcset with picturefill where currentSrc isn't available\n\t\tif (!el[pf.ns] || !el[pf.ns].evaled) {\n\t\t\t// force synchronous srcset parsing\n\t\t\tpf.fillImg(el, {reselect: true});\n\t\t}\n\n\t\tif (!el[pf.ns].curSrc) {\n\t\t\t// force picturefill to parse srcset\n\t\t\tel[pf.ns].supported = false;\n\t\t\tpf.fillImg(el, {reselect: true});\n\t\t}\n\n\t\t// retrieve parsed currentSrc, if any\n\t\tel.currentSrc = el[pf.ns].curSrc || el.src;\n\t}\n}\n\nfunction getStyle(el) {\n\tvar style = getComputedStyle(el).fontFamily;\n\tvar parsed;\n\tvar props = {};\n\twhile ((parsed = propRegex.exec(style)) !== null) {\n\t\tprops[parsed[1]] = parsed[2];\n\t}\n\treturn props;\n}\n\nfunction setPlaceholder(img, width, height) {\n\t// Default: fill width, no height\n\tvar placeholder = createPlaceholder(width || 1, height || 0);\n\n\t// Only set placeholder if it's different\n\tif (nativeGetAttribute.call(img, 'src') !== placeholder) {\n\t\tnativeSetAttribute.call(img, 'src', placeholder);\n\t}\n}\n\nfunction onImageReady(img, callback) {\n\t// naturalWidth is only available when the image headers are loaded,\n\t// this loop will poll it every 100ms.\n\tif (img.naturalWidth) {\n\t\tcallback(img);\n\t} else {\n\t\tsetTimeout(onImageReady, 100, img, callback);\n\t}\n}\n\nfunction fixOne(el) {\n\tvar style = getStyle(el);\n\tvar ofi = el[OFI];\n\tstyle['object-fit'] = style['object-fit'] || 'fill'; // default value\n\n\t// Avoid running where unnecessary, unless OFI had already done its deed\n\tif (!ofi.img) {\n\t\t// fill is the default behavior so no action is necessary\n\t\tif (style['object-fit'] === 'fill') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Where object-fit is supported and object-position isn't (Safari < 10)\n\t\tif (\n\t\t\t!ofi.skipTest && // unless user wants to apply regardless of browser support\n\t\t\tsupportsObjectFit && // if browser already supports object-fit\n\t\t\t!style['object-position'] // unless object-position is used\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// keep a clone in memory while resetting the original to a blank\n\tif (!ofi.img) {\n\t\tofi.img = new Image(el.width, el.height);\n\t\tofi.img.srcset = nativeGetAttribute.call(el, \"data-ofi-srcset\") || el.srcset;\n\t\tofi.img.src = nativeGetAttribute.call(el, \"data-ofi-src\") || el.src;\n\n\t\t// preserve for any future cloneNode calls\n\t\t// https://github.com/bfred-it/object-fit-images/issues/53\n\t\tnativeSetAttribute.call(el, \"data-ofi-src\", el.src);\n\t\tif (el.srcset) {\n\t\t\tnativeSetAttribute.call(el, \"data-ofi-srcset\", el.srcset);\n\t\t}\n\n\t\tsetPlaceholder(el, el.naturalWidth || el.width, el.naturalHeight || el.height);\n\n\t\t// remove srcset because it overrides src\n\t\tif (el.srcset) {\n\t\t\tel.srcset = '';\n\t\t}\n\t\ttry {\n\t\t\tkeepSrcUsable(el);\n\t\t} catch (err) {\n\t\t\tif (window.console) {\n\t\t\t\tconsole.log('http://bit.ly/ofi-old-browser');\n\t\t\t}\n\t\t}\n\t}\n\n\tpolyfillCurrentSrc(ofi.img);\n\n\tel.style.backgroundImage = \"url(\" + ((ofi.img.currentSrc || ofi.img.src).replace('(', '%28').replace(')', '%29')) + \")\";\n\tel.style.backgroundPosition = style['object-position'] || 'center';\n\tel.style.backgroundRepeat = 'no-repeat';\n\n\tif (/scale-down/.test(style['object-fit'])) {\n\t\tonImageReady(ofi.img, function () {\n\t\t\tif (ofi.img.naturalWidth > el.width || ofi.img.naturalHeight > el.height) {\n\t\t\t\tel.style.backgroundSize = 'contain';\n\t\t\t} else {\n\t\t\t\tel.style.backgroundSize = 'auto';\n\t\t\t}\n\t\t});\n\t} else {\n\t\tel.style.backgroundSize = style['object-fit'].replace('none', 'auto').replace('fill', '100% 100%');\n\t}\n\n\tonImageReady(ofi.img, function (img) {\n\t\tsetPlaceholder(el, img.naturalWidth, img.naturalHeight);\n\t});\n}\n\nfunction keepSrcUsable(el) {\n\tvar descriptors = {\n\t\tget: function get(prop) {\n\t\t\treturn el[OFI].img[prop ? prop : 'src'];\n\t\t},\n\t\tset: function set(value, prop) {\n\t\t\tel[OFI].img[prop ? prop : 'src'] = value;\n\t\t\tnativeSetAttribute.call(el, (\"data-ofi-\" + prop), value); // preserve for any future cloneNode\n\t\t\tfixOne(el);\n\t\t\treturn value;\n\t\t}\n\t};\n\tObject.defineProperty(el, 'src', descriptors);\n\tObject.defineProperty(el, 'currentSrc', {\n\t\tget: function () { return descriptors.get('currentSrc'); }\n\t});\n\tObject.defineProperty(el, 'srcset', {\n\t\tget: function () { return descriptors.get('srcset'); },\n\t\tset: function (ss) { return descriptors.set(ss, 'srcset'); }\n\t});\n}\n\nfunction hijackAttributes() {\n\tfunction getOfiImageMaybe(el, name) {\n\t\treturn el[OFI] && el[OFI].img && (name === 'src' || name === 'srcset') ? el[OFI].img : el;\n\t}\n\tif (!supportsObjectPosition) {\n\t\tHTMLImageElement.prototype.getAttribute = function (name) {\n\t\t\treturn nativeGetAttribute.call(getOfiImageMaybe(this, name), name);\n\t\t};\n\n\t\tHTMLImageElement.prototype.setAttribute = function (name, value) {\n\t\t\treturn nativeSetAttribute.call(getOfiImageMaybe(this, name), name, String(value));\n\t\t};\n\t}\n}\n\nfunction fix(imgs, opts) {\n\tvar startAutoMode = !autoModeEnabled && !imgs;\n\topts = opts || {};\n\timgs = imgs || 'img';\n\n\tif ((supportsObjectPosition && !opts.skipTest) || !supportsOFI) {\n\t\treturn false;\n\t}\n\n\t// use imgs as a selector or just select all images\n\tif (typeof imgs === 'string') {\n\t\timgs = document.querySelectorAll(imgs);\n\t} else if (!('length' in imgs)) {\n\t\timgs = [imgs];\n\t}\n\n\t// apply fix to all\n\tfor (var i = 0; i < imgs.length; i++) {\n\t\timgs[i][OFI] = imgs[i][OFI] || {\n\t\t\tskipTest: opts.skipTest\n\t\t};\n\t\tfixOne(imgs[i]);\n\t}\n\n\tif (startAutoMode) {\n\t\tdocument.body.addEventListener('load', function (e) {\n\t\t\tif (e.target.tagName === 'IMG') {\n\t\t\t\tfix(e.target, {\n\t\t\t\t\tskipTest: opts.skipTest\n\t\t\t\t});\n\t\t\t}\n\t\t}, true);\n\t\tautoModeEnabled = true;\n\t\timgs = 'img'; // reset to a generic selector for watchMQ\n\t}\n\n\t// if requested, watch media queries for object-fit change\n\tif (opts.watchMQ) {\n\t\twindow.addEventListener('resize', fix.bind(null, imgs, {\n\t\t\tskipTest: opts.skipTest\n\t\t}));\n\t}\n}\n\nfix.supportsObjectFit = supportsObjectFit;\nfix.supportsObjectPosition = supportsObjectPosition;\n\nhijackAttributes();\n\nexport default fix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-fit-images/dist/ofi.es-modules.js\n// module id = 1\n// module chunks = 0","/**\n * Object Fit Videos\n * Polyfill for object-fit and object-position CSS properties on video elements\n * Covers IE9, IE10, IE11, Edge, Safari <10\n *\n * Usage\n * In your CSS, add a special font-family tag for IE/Edge\n * video {\n *   object-fit: cover;\n *   font-family: 'object-fit: cover;';\n * }\n *\n * Before the closing body tag, or whenever the DOM is ready,\n * make the JavaScript call\n * objectFitVideos();\n *\n * All video elements with the special CSS property will be targeted\n *\n * @license  MIT (https://opensource.org/licenses/MIT)\n * @author   Todd Miller <todd.miller@tricomb2b.com>\n * @version  1.0.2\n * @changelog\n * 2016-08-19 - Adds object-position support.\n * 2016-08-19 - Add throttle function for more performant resize events\n * 2016-08-19 - Initial release with object-fit support, and\n *              object-position default 'center'\n * 2016-10-14 - No longer relies on window load event, instead requires a specific\n *              function call to initialize the videos for object fit and position.\n * 2016-11-28 - Support CommonJS environment, courtesy of @msorensson\n * 2016-12-05 - Refactors the throttling function to support IE\n */\nvar objectFitVideos = function (videos) {\n  'use strict';\n\n  var testImg                = new Image(),\n      supportsObjectFit      = 'object-fit' in testImg.style,\n      supportsObjectPosition = 'object-position' in testImg.style,\n      propRegex              = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\n\n  if (!supportsObjectFit || !supportsObjectPosition) {\n    initialize(videos);\n    throttle('resize', 'optimizedResize');\n  }\n\n  /**\n   * Parse the style and look for the special font-family tag\n   * @param  {object} $el The element to parse\n   * @return {object}     The font-family properties we're interested in\n   */\n  function getStyle ($el) {\n    var style  = getComputedStyle($el).fontFamily,\n        parsed = null,\n        props  = {};\n\n      while ((parsed = propRegex.exec(style)) !== null) {\n        props[parsed[1]] = parsed[2];\n      }\n\n      if (props['object-position'])\n        return parsePosition(props);\n\n      return props;\n  }\n\n  /**\n   * Initialize all the relevant video elements and get them fitted\n   */\n  function initialize (videos) {\n    var index  = -1;\n    videos = videos || 'video';\n\n    // use videos as a selector or just select all videos\n    if (typeof videos === 'string') {\n      videos = document.querySelectorAll(videos);\n    } else if (!('length' in videos)) {\n      videos = [videos];\n    }\n\n    while (videos[++index]) {\n      var style = getStyle(videos[index]);\n\n      // only do work if the property is on the element\n      if (style['object-fit'] || style['object-position']) {\n        // set the default values\n        style['object-fit'] = style['object-fit'] || 'fill';\n        fitIt(videos[index], style);\n      }\n    }\n  }\n\n  /**\n   * Object Fit\n   * @param  {object} $el Element to fit\n   * @return {object}     The element's relevant properties\n   */\n  function fitIt ($el, style) {\n    // fill is the default behavior, no action is necessary\n    if (style['object-fit'] === 'fill')\n      return;\n\n    // convenience style properties on the source element\n    var setCss = $el.style,\n        getCss = window.getComputedStyle($el);\n\n    // create and insert a wrapper element\n    var $wrap = document.createElement('object-fit');\n    $wrap.appendChild($el.parentNode.replaceChild($wrap, $el));\n\n    // style the wrapper element to mostly match the source element\n    var wrapCss = {\n      height:    '100%',\n      width:     '100%',\n      boxSizing: 'content-box',\n      display:   'inline-block',\n      overflow:  'hidden'\n    };\n\n    'backgroundColor backgroundImage borderColor borderStyle borderWidth bottom fontSize lineHeight left opacity margin position right top visibility'.replace(/\\w+/g, function (key) {\n      wrapCss[key] = getCss[key];\n    });\n\n    for (var key in wrapCss)\n      $wrap.style[key] = wrapCss[key];\n\n    // give the source element some saner styles\n    setCss.border  = setCss.margin = setCss.padding = 0;\n    setCss.display = 'block';\n    setCss.opacity = 1;\n\n    // set up the event handlers\n    $el.addEventListener('loadedmetadata', doWork);\n    window.addEventListener('optimizedResize', doWork);\n\n    // we may have missed the loadedmetadata event, so if the video has loaded\n    // enough data, just drop the event listener and execute\n    if ($el.readyState >= 1) {\n      $el.removeEventListener('loadedmetadata', doWork);\n      doWork();\n    }\n\n    /**\n     * Do the actual sizing. Math.\n     * @methodOf fitIt\n     */\n    function doWork () {\n      // the actual size and ratio of the video\n      // we do this here, even though it doesn't change, because\n      // at this point we can be sure the metadata has loaded\n      var videoWidth  = $el.videoWidth,\n          videoHeight = $el.videoHeight,\n          videoRatio  = videoWidth / videoHeight;\n\n      var wrapWidth  = $wrap.clientWidth,\n          wrapHeight = $wrap.clientHeight,\n          wrapRatio  = wrapWidth / wrapHeight;\n\n      var newHeight = 0,\n          newWidth  = 0;\n      setCss.marginLeft = setCss.marginTop = 0;\n\n      // basically we do the opposite action for contain and cover,\n      // depending on whether the video aspect ratio is less than or\n      // greater than the wrapper's aspect ratio\n      if (videoRatio < wrapRatio ?\n          style['object-fit'] === 'contain' : style['object-fit'] === 'cover') {\n        newHeight = wrapHeight * videoRatio;\n        newWidth  = wrapWidth / videoRatio;\n\n        setCss.width  = Math.round(newHeight) + 'px';\n        setCss.height = wrapHeight + 'px';\n\n        if (style['object-position-x'] === 'left')\n          setCss.marginLeft = 0;\n        else if (style['object-position-x'] === 'right')\n          setCss.marginLeft = Math.round(wrapWidth - newHeight) + 'px';\n        else\n          setCss.marginLeft = Math.round((wrapWidth - newHeight) / 2) + 'px';\n      } else {\n        newWidth = wrapWidth / videoRatio;\n\n        setCss.width     = wrapWidth + 'px';\n        setCss.height    = Math.round(newWidth) + 'px';\n\n        if (style['object-position-y'] === 'top')\n          setCss.marginTop = 0;\n        else if (style['object-position-y'] === 'bottom')\n          setCss.marginTop = Math.round(wrapHeight - newWidth) + 'px';\n        else\n          setCss.marginTop = Math.round((wrapHeight - newWidth) / 2) + 'px';\n      }\n    }\n  }\n\n  /**\n   * Split the object-position property into x and y position properties\n   * @param  {object} style Relevant element styles\n   * @return {object}       The style object with the added x and y props\n   */\n  function parsePosition (style) {\n    if (~style['object-position'].indexOf('left'))\n      style['object-position-x'] = 'left';\n    else if (~style['object-position'].indexOf('right'))\n      style['object-position-x'] = 'right';\n    else\n      style['object-position-x'] = 'center';\n\n    if (~style['object-position'].indexOf('top'))\n      style['object-position-y'] = 'top';\n    else if (~style['object-position'].indexOf('bottom'))\n      style['object-position-y'] = 'bottom';\n    else\n      style['object-position-y'] = 'center';\n\n    return style;\n  }\n\n  /**\n   * Throttle an event with RequestAnimationFrame API for better performance\n   * @param  {string} type The event to throttle\n   * @param  {string} name Custom event name to listen for\n   * @param  {object} obj  Optional object to attach the event to\n   */\n  function throttle (type, name, obj) {\n    obj = obj || window;\n    var running = false,\n        evt     = null;\n\n    // IE does not support the CustomEvent constructor\n    // so if that fails do it the old way\n    try {\n      evt = new CustomEvent(name);\n    } catch (e) {\n      evt = document.createEvent('Event');\n      evt.initEvent(name, true, true);\n    }\n\n    var func = function () {\n      if (running) return;\n\n      running = true;\n      requestAnimationFrame(function () {\n        obj.dispatchEvent(evt);\n        running = false;\n      });\n    };\n\n    obj.addEventListener(type, func);\n  }\n};\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\n  module.exports = objectFitVideos;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-fit-videos/object-fit-videos.js\n// module id = 2\n// module chunks = 0","/*! npm.im/intervalometer */\nfunction intervalometer(cb, request, cancel, requestParameter) {\n\tvar requestId;\n\tvar previousLoopTime;\n\tfunction loop(now) {\n\t\t// must be requested before cb() because that might call .stop()\n\t\trequestId = request(loop, requestParameter);\n\n\t\t// called with \"ms since last call\". 0 on start()\n\t\tcb(now - (previousLoopTime || now));\n\n\t\tpreviousLoopTime = now;\n\t}\n\treturn {\n\t\tstart: function start() {\n\t\t\tif (!requestId) { // prevent double starts\n\t\t\t\tloop(0);\n\t\t\t}\n\t\t},\n\t\tstop: function stop() {\n\t\t\tcancel(requestId);\n\t\t\trequestId = null;\n\t\t\tpreviousLoopTime = 0;\n\t\t}\n\t};\n}\n\nfunction frameIntervalometer(cb) {\n\treturn intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);\n}\n\nfunction timerIntervalometer(cb, delay) {\n\treturn intervalometer(cb, setTimeout, clearTimeout, delay);\n}\n\nexport { intervalometer, frameIntervalometer, timerIntervalometer };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/intervalometer/dist/intervalometer.es-modules.js\n// module id = 3\n// module chunks = 0","import objectFitImage from 'object-fit-images'\nimport objectFitVideo from 'object-fit-videos'\nimport enableInlineVideo from 'iphone-inline-video'\n\nconst CLASS_FEATURE = '.ft-fit-bg'\nconst CLASS_INITIAL_HIDE = '-initial-hide'\n\n/**\n * Object fit feature class.\n */\nclass ObjectFit extends base.features.Feature {\n\n  init() {\n    this._objectFit = this.node.getAttribute('data-object-fit')\n    this._objectPosition = this.node.getAttribute('data-object-position')\n\n    if (this._objectFit && this._objectPosition) {\n      this.node.style.objectFit = this._objectFit\n      this.node.style.objectPosition = this._objectPosition\n      this.node.style.fontFamily = `\"object-fit: ${this._objectFit}; object-position: ${this._objectPosition}\"`\n    } else if (this._objectFit) {\n      this.node.style.objectFit = this._objectFit\n      this.node.style.fontFamily = `\"object-fit: ${this._objectFit}; object-position: ${this.options.defaultObjectPosition}\"`\n    } else  if (this._objectPosition) {\n      this.node.style.objectPosition = this._objectPosition\n      this.node.style.fontFamily = `\"object-fit: ${this.options.defaultObjectFit}; object-position: ${this._objectPosition}\"`\n    }\n\n    if (this.node.nodeName.toLowerCase() == 'video') {\n      objectFitVideo(this.node)\n      enableInlineVideo(this.node, {\n          iPad: this.options.iPad\n      })\n\n      if (this.node.autoplay) this.node.play()\n    } else {\n      objectFitImage(this.node, {\n        watchMQ: this.options.watchMQ\n      })\n    }\n\n    // remove initial hide class\n    base.utils.fn.rAF(() => {\n      if (this.node.parentElement.tagName.toLowerCase() === 'object-fit') {\n        this.node.parentElement.style.visibility = 'visible'\n      }\n\n      this.node.closest(CLASS_FEATURE).classList.remove(CLASS_INITIAL_HIDE)\n    })\n  }\n\n}\n\n/**\n * Default feature options (also used to initialize object-fit-images and iphone-inline-video library).\n *\n * @see https://github.com/bfred-it/object-fit-images\n *\n * @type {Object}\n * @property {Boolean} watchMQ=false\n *   This enables the automatic re-fix of the selected images when the window resizes.\n *   You only need it in some cases\n * @property {String} defaultObjectFit='cover'\n *   Default object fit used when only `data-object-position` is defined\n * @property {String} defaultObjectPosition='center center'\n *   Default object position used when only `data-object-fit` is defined\n */\nObjectFit.defaultOptions = {\n  iPad: true,\n  watchMQ: false,\n  defaultObjectFit: 'cover',\n  defaultObjectPosition: 'center center'\n}\n\nexport default ObjectFit\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}