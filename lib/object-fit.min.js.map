{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///object-fit.min.js","webpack:///webpack/bootstrap cc3bf11d057ab4eac526","webpack:///./~/iphone-inline-video/dist/iphone-inline-video.es-modules.js","webpack:///./~/object-fit-images/dist/ofi.common-js.js","webpack:///./~/object-fit-videos/object-fit-videos.js","webpack:///./~/intervalometer/dist/intervalometer.es-modules.js","webpack:///./src/index.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","preventEvent","element","eventName","test","handler","e","stopImmediatePropagation","addEventListener","proxyProperty","propertyName","sourceObject","copyFirst","set","proxyEvent","dispatchEvent","Event","dispatchEventAsync","type","Promise","resolve","then","getAudioFromVideo","video","audio","Audio","crossOrigin","src","currentSrc","setTime","time","rememberOnly","lastTimeupdateEvent","Date","now","IIVEvent","currentTime","lastRequests","requestIndex","isPlayerEnded","player","driver","duration","update","timeDiff","readyState","HAVE_FUTURE_DATA","hasAudio","playbackRate","loop","networkState","NETWORK_IDLE","buffered","length","load","ended","pause","play","IIV","webkitDisplayingFullscreen","IIVPlay","paused","updater","start","HAVE_ENOUGH_DATA","forceEvents","stop","IIVPause","addPlayer","__WEBPACK_IMPORTED_MODULE_0_intervalometer__","bind","muted","wasEmpty","autoplay","indexOf","preventWithPropOrFullscreen","el","isAllowed","overloadAPI","enableInlineVideo","opts","everywhere","iOS8or9","iPad","ipad","navigator","userAgent","willAutoplay","classList","add","restoreAutoplay","removeEventListener","platform","console","warn","document","head","style","matchMedia","matches","createPlaceholder","w","h","polyfillCurrentSrc","srcset","supportsCurrentSrc","window","picturefill","pf","_","ns","evaled","fillImg","reselect","curSrc","supported","getStyle","getComputedStyle","fontFamily","parsed","props","propRegex","exec","setPlaceholder","img","width","height","placeholder","nativeGetAttribute","nativeSetAttribute","onImageReady","callback","naturalWidth","setTimeout","fixOne","ofi","OFI","skipTest","supportsObjectFit","Image","naturalHeight","keepSrcUsable","err","backgroundImage","replace","backgroundPosition","backgroundRepeat","backgroundOrigin","backgroundSize","descriptors","prop","ss","hijackAttributes","getOfiImageMaybe","supportsObjectPosition","HTMLImageElement","getAttribute","setAttribute","String","fix","imgs","startAutoMode","autoModeEnabled","supportsOFI","getElementsByTagName","querySelectorAll","body","target","tagName","watchMQ","testImg","object-position","objectFitVideos","videos","$el","parsePosition","initialize","index","fitIt","doWork","videoWidth","videoHeight","videoRatio","wrapWidth","$wrap","clientWidth","wrapHeight","clientHeight","wrapRatio","newHeight","newWidth","setCss","marginLeft","marginTop","Math","round","getCss","createElement","appendChild","parentNode","replaceChild","wrapCss","boxSizing","display","overflow","key","border","margin","padding","opacity","throttle","obj","running","evt","CustomEvent","createEvent","initEvent","func","requestAnimationFrame","isEdge","intervalometer","cb","request","cancel","requestParameter","requestId","previousLoopTime","frameIntervalometer","cancelAnimationFrame","timerIntervalometer","delay","clearTimeout","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","mod","apply","undefined","_objectFitImages","_objectFitVideos","_iphoneInlineVideo","_interopRequireDefault","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_objectFitImages2","_objectFitVideos2","_iphoneInlineVideo2","_createClass","defineProperties","descriptor","protoProps","staticProps","CLASS_FEATURE","ObjectFit","_base$features$Featur","getPrototypeOf","arguments","init","_this2","_objectFit","node","_objectPosition","objectFit","objectPosition","options","defaultObjectPosition","defaultObjectFit","nodeName","toLowerCase","onload","HAVE_CURRENT_DATA","_removeInitialHide","waitForMediaLoaded","_this3","parentElement","visibility","featureParent","closest","remove","classInitialHide","base","features","Feature","defaultOptions"],"mappings":"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","file":"object-fit.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"object-fit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"object-fit\"] = factory();\n\telse\n\t\troot[\"object-fit\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"object-fit\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"object-fit\"] = factory();\n\telse\n\t\troot[\"object-fit\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_intervalometer__ = __webpack_require__(3);\n/*! npm.im/iphone-inline-video 2.2.2 */\n\n\nfunction preventEvent(element, eventName, test) {\n\tfunction handler(e) {\n\t\tif (!test || test(element, eventName)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// // console.log(eventName, 'prevented on', element);\n\t\t}\n\t}\n\telement.addEventListener(eventName, handler);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// // if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// // }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// Allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[IIVEvent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n\t\t// This should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// // console.log('Will load');\n\t}\n\n\t// // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[IIVEvent]; // Allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// // console.log('play');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\t// If it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPlay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// // console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (video.buffered.length === 0) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// // console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// // console.log('pause');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// If it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\n\t// Handle the 'ended' event only if it's not fullscreen\n\tif (video.ended && !video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVEvent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = {};\n\tvideo[IIV] = player;\n\tplayer.paused = true; // Track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_intervalometer__[\"a\" /* frameIntervalometer */])(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// // console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// Media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// // console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// // console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// Playing videos will only keep playing if no src was present when .play()â€™ed\n\t\t\tif (wasEmpty || (!hasAudio && video.autoplay)) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// Stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// Make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// Play video natively\n\t\t\tvideo[IIVPlay]();\n\t\t} else if (hasAudio && player.driver.buffered.length === 0) {\n\t\t\t// If the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// Sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// Allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// // console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction preventWithPropOrFullscreen(el) {\n\tvar isAllowed = el[IIVEvent];\n\tdelete el[IIVEvent];\n\treturn !el.webkitDisplayingFullscreen && !isAllowed;\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[IIV];\n\tvideo[IIVPlay] = video.play;\n\tvideo[IIVPause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\n\t// IIV works by seeking 60 times per second.\n\t// These events are now useless.\n\tpreventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });\n\tpreventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });\n\n\t// Limit timeupdate events\n\tpreventEvent(video, 'timeupdate', preventWithPropOrFullscreen);\n\n\t// Prevent occasional native ended events\n\tpreventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\n\nfunction enableInlineVideo(video, opts) {\n\tif ( opts === void 0 ) opts = {};\n\n\t// Stop if already enabled\n\tif (video[IIV]) {\n\t\treturn;\n\t}\n\n\t// Allow the user to skip detection\n\tif (!opts.everywhere) {\n\t\t// Only iOS8 and 9 are supported\n\t\tif (!iOS8or9) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop if it's not an allowed device\n\t\tif (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Try to pause\n\tvideo.pause();\n\n\t// Prevent autoplay.\n\t// An non-started autoplaying video can't be .pause()'d\n\tvar willAutoplay = video.autoplay;\n\tvideo.autoplay = false;\n\n\taddPlayer(video, !video.muted);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\n\t// Autoplay\n\tif (video.muted && willAutoplay) {\n\t\tvideo.play();\n\t\tvideo.addEventListener('playing', function restoreAutoplay() {\n\t\t\tvideo.autoplay = true;\n\t\t\tvideo.removeEventListener('playing', restoreAutoplay);\n\t\t});\n\t}\n\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = enableInlineVideo;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*! npm.im/object-fit-images 3.2.3 */\n\n\nvar OFI = 'bfred-it:object-fit-images';\nvar propRegex = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\nvar testImg = typeof Image === 'undefined' ? {style: {'object-position': 1}} : new Image();\nvar supportsObjectFit = 'object-fit' in testImg.style;\nvar supportsObjectPosition = 'object-position' in testImg.style;\nvar supportsOFI = 'background-size' in testImg.style;\nvar supportsCurrentSrc = typeof testImg.currentSrc === 'string';\nvar nativeGetAttribute = testImg.getAttribute;\nvar nativeSetAttribute = testImg.setAttribute;\nvar autoModeEnabled = false;\n\nfunction createPlaceholder(w, h) {\n\treturn (\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='\" + w + \"' height='\" + h + \"'%3E%3C/svg%3E\");\n}\n\nfunction polyfillCurrentSrc(el) {\n\tif (el.srcset && !supportsCurrentSrc && window.picturefill) {\n\t\tvar pf = window.picturefill._;\n\t\t// parse srcset with picturefill where currentSrc isn't available\n\t\tif (!el[pf.ns] || !el[pf.ns].evaled) {\n\t\t\t// force synchronous srcset parsing\n\t\t\tpf.fillImg(el, {reselect: true});\n\t\t}\n\n\t\tif (!el[pf.ns].curSrc) {\n\t\t\t// force picturefill to parse srcset\n\t\t\tel[pf.ns].supported = false;\n\t\t\tpf.fillImg(el, {reselect: true});\n\t\t}\n\n\t\t// retrieve parsed currentSrc, if any\n\t\tel.currentSrc = el[pf.ns].curSrc || el.src;\n\t}\n}\n\nfunction getStyle(el) {\n\tvar style = getComputedStyle(el).fontFamily;\n\tvar parsed;\n\tvar props = {};\n\twhile ((parsed = propRegex.exec(style)) !== null) {\n\t\tprops[parsed[1]] = parsed[2];\n\t}\n\treturn props;\n}\n\nfunction setPlaceholder(img, width, height) {\n\t// Default: fill width, no height\n\tvar placeholder = createPlaceholder(width || 1, height || 0);\n\n\t// Only set placeholder if it's different\n\tif (nativeGetAttribute.call(img, 'src') !== placeholder) {\n\t\tnativeSetAttribute.call(img, 'src', placeholder);\n\t}\n}\n\nfunction onImageReady(img, callback) {\n\t// naturalWidth is only available when the image headers are loaded,\n\t// this loop will poll it every 100ms.\n\tif (img.naturalWidth) {\n\t\tcallback(img);\n\t} else {\n\t\tsetTimeout(onImageReady, 100, img, callback);\n\t}\n}\n\nfunction fixOne(el) {\n\tvar style = getStyle(el);\n\tvar ofi = el[OFI];\n\tstyle['object-fit'] = style['object-fit'] || 'fill'; // default value\n\n\t// Avoid running where unnecessary, unless OFI had already done its deed\n\tif (!ofi.img) {\n\t\t// fill is the default behavior so no action is necessary\n\t\tif (style['object-fit'] === 'fill') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Where object-fit is supported and object-position isn't (Safari < 10)\n\t\tif (\n\t\t\t!ofi.skipTest && // unless user wants to apply regardless of browser support\n\t\t\tsupportsObjectFit && // if browser already supports object-fit\n\t\t\t!style['object-position'] // unless object-position is used\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// keep a clone in memory while resetting the original to a blank\n\tif (!ofi.img) {\n\t\tofi.img = new Image(el.width, el.height);\n\t\tofi.img.srcset = nativeGetAttribute.call(el, \"data-ofi-srcset\") || el.srcset;\n\t\tofi.img.src = nativeGetAttribute.call(el, \"data-ofi-src\") || el.src;\n\n\t\t// preserve for any future cloneNode calls\n\t\t// https://github.com/bfred-it/object-fit-images/issues/53\n\t\tnativeSetAttribute.call(el, \"data-ofi-src\", el.src);\n\t\tif (el.srcset) {\n\t\t\tnativeSetAttribute.call(el, \"data-ofi-srcset\", el.srcset);\n\t\t}\n\n\t\tsetPlaceholder(el, el.naturalWidth || el.width, el.naturalHeight || el.height);\n\n\t\t// remove srcset because it overrides src\n\t\tif (el.srcset) {\n\t\t\tel.srcset = '';\n\t\t}\n\t\ttry {\n\t\t\tkeepSrcUsable(el);\n\t\t} catch (err) {\n\t\t\tif (window.console) {\n\t\t\t\tconsole.warn('https://bit.ly/ofi-old-browser');\n\t\t\t}\n\t\t}\n\t}\n\n\tpolyfillCurrentSrc(ofi.img);\n\n\tel.style.backgroundImage = \"url(\\\"\" + ((ofi.img.currentSrc || ofi.img.src).replace(/\"/g, '\\\\\"')) + \"\\\")\";\n\tel.style.backgroundPosition = style['object-position'] || 'center';\n\tel.style.backgroundRepeat = 'no-repeat';\n\tel.style.backgroundOrigin = 'content-box';\n\n\tif (/scale-down/.test(style['object-fit'])) {\n\t\tonImageReady(ofi.img, function () {\n\t\t\tif (ofi.img.naturalWidth > el.width || ofi.img.naturalHeight > el.height) {\n\t\t\t\tel.style.backgroundSize = 'contain';\n\t\t\t} else {\n\t\t\t\tel.style.backgroundSize = 'auto';\n\t\t\t}\n\t\t});\n\t} else {\n\t\tel.style.backgroundSize = style['object-fit'].replace('none', 'auto').replace('fill', '100% 100%');\n\t}\n\n\tonImageReady(ofi.img, function (img) {\n\t\tsetPlaceholder(el, img.naturalWidth, img.naturalHeight);\n\t});\n}\n\nfunction keepSrcUsable(el) {\n\tvar descriptors = {\n\t\tget: function get(prop) {\n\t\t\treturn el[OFI].img[prop ? prop : 'src'];\n\t\t},\n\t\tset: function set(value, prop) {\n\t\t\tel[OFI].img[prop ? prop : 'src'] = value;\n\t\t\tnativeSetAttribute.call(el, (\"data-ofi-\" + prop), value); // preserve for any future cloneNode\n\t\t\tfixOne(el);\n\t\t\treturn value;\n\t\t}\n\t};\n\tObject.defineProperty(el, 'src', descriptors);\n\tObject.defineProperty(el, 'currentSrc', {\n\t\tget: function () { return descriptors.get('currentSrc'); }\n\t});\n\tObject.defineProperty(el, 'srcset', {\n\t\tget: function () { return descriptors.get('srcset'); },\n\t\tset: function (ss) { return descriptors.set(ss, 'srcset'); }\n\t});\n}\n\nfunction hijackAttributes() {\n\tfunction getOfiImageMaybe(el, name) {\n\t\treturn el[OFI] && el[OFI].img && (name === 'src' || name === 'srcset') ? el[OFI].img : el;\n\t}\n\tif (!supportsObjectPosition) {\n\t\tHTMLImageElement.prototype.getAttribute = function (name) {\n\t\t\treturn nativeGetAttribute.call(getOfiImageMaybe(this, name), name);\n\t\t};\n\n\t\tHTMLImageElement.prototype.setAttribute = function (name, value) {\n\t\t\treturn nativeSetAttribute.call(getOfiImageMaybe(this, name), name, String(value));\n\t\t};\n\t}\n}\n\nfunction fix(imgs, opts) {\n\tvar startAutoMode = !autoModeEnabled && !imgs;\n\topts = opts || {};\n\timgs = imgs || 'img';\n\n\tif ((supportsObjectPosition && !opts.skipTest) || !supportsOFI) {\n\t\treturn false;\n\t}\n\n\t// use imgs as a selector or just select all images\n\tif (imgs === 'img') {\n\t\timgs = document.getElementsByTagName('img');\n\t} else if (typeof imgs === 'string') {\n\t\timgs = document.querySelectorAll(imgs);\n\t} else if (!('length' in imgs)) {\n\t\timgs = [imgs];\n\t}\n\n\t// apply fix to all\n\tfor (var i = 0; i < imgs.length; i++) {\n\t\timgs[i][OFI] = imgs[i][OFI] || {\n\t\t\tskipTest: opts.skipTest\n\t\t};\n\t\tfixOne(imgs[i]);\n\t}\n\n\tif (startAutoMode) {\n\t\tdocument.body.addEventListener('load', function (e) {\n\t\t\tif (e.target.tagName === 'IMG') {\n\t\t\t\tfix(e.target, {\n\t\t\t\t\tskipTest: opts.skipTest\n\t\t\t\t});\n\t\t\t}\n\t\t}, true);\n\t\tautoModeEnabled = true;\n\t\timgs = 'img'; // reset to a generic selector for watchMQ\n\t}\n\n\t// if requested, watch media queries for object-fit change\n\tif (opts.watchMQ) {\n\t\twindow.addEventListener('resize', fix.bind(null, imgs, {\n\t\t\tskipTest: opts.skipTest\n\t\t}));\n\t}\n}\n\nfix.supportsObjectFit = supportsObjectFit;\nfix.supportsObjectPosition = supportsObjectPosition;\n\nhijackAttributes();\n\nmodule.exports = fix;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n * Object Fit Videos\n * Polyfill for object-fit and object-position CSS properties on video elements\n * Covers IE9, IE10, IE11, Edge, Safari <10\n *\n * Usage\n * In your CSS, add a special font-family tag for IE/Edge\n * video {\n *   object-fit: cover;\n *   font-family: 'object-fit: cover;';\n * }\n *\n * Before the closing body tag, or whenever the DOM is ready,\n * make the JavaScript call\n * objectFitVideos();\n *\n * All video elements with the special CSS property will be targeted\n *\n * @license  MIT (https://opensource.org/licenses/MIT)\n * @author   Todd Miller <todd.miller@tricomb2b.com>\n * @version  1.0.2\n * @changelog\n * 2016-08-19 - Adds object-position support.\n * 2016-08-19 - Add throttle function for more performant resize events\n * 2016-08-19 - Initial release with object-fit support, and\n *              object-position default 'center'\n * 2016-10-14 - No longer relies on window load event, instead requires a specific\n *              function call to initialize the videos for object fit and position.\n * 2016-11-28 - Support CommonJS environment, courtesy of @msorensson\n * 2016-12-05 - Refactors the throttling function to support IE\n * 2017-09-26 - Fix an issue with autplay not working on polyfilled videos\n *            - Adds the capability to specify elements to polyfill,\n *              instead of just checking every video element for the\n *              CSS property. Slight performance gain in most usecases,\n *              and a bigger gain in a few usecases.\n * 2017-10-24 - Add user agent check to enable polyfill for all Edge browsers.\n *              object-fit is supported on Edge >= 16, but currently just for images.\n */\nvar objectFitVideos = function (videos) {\n  'use strict';\n\n  var isEdge = navigator.userAgent.indexOf('Edge/') >= 0;\n\n  var testImg                = new Image(),\n      supportsObjectFit      = 'object-fit' in testImg.style && !isEdge,\n      supportsObjectPosition = 'object-position' in testImg.style && !isEdge,\n      propRegex              = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\n\n  if (!supportsObjectFit || !supportsObjectPosition) {\n    initialize(videos);\n    throttle('resize', 'optimizedResize');\n  }\n\n  /**\n   * Parse the style and look for the special font-family tag\n   * @param  {object} $el The element to parse\n   * @return {object}     The font-family properties we're interested in\n   */\n  function getStyle ($el) {\n    var style  = getComputedStyle($el).fontFamily,\n        parsed = null,\n        props  = {};\n\n      while ((parsed = propRegex.exec(style)) !== null) {\n        props[parsed[1]] = parsed[2];\n      }\n\n      if (props['object-position'])\n        return parsePosition(props);\n\n      return props;\n  }\n\n  /**\n   * Initialize all the relevant video elements and get them fitted\n   */\n  function initialize (videos) {\n    var index = -1;\n\n    if (!videos) {\n      // if no videos given, query all video elements\n      videos = document.querySelectorAll('video');\n    } else if (!('length' in videos)) {\n      // convert to an array for proper looping if an array or NodeList\n      // was not given\n      videos = [videos];\n    }\n\n    while (videos[++index]) {\n      var style = getStyle(videos[index]);\n\n      // only do work if the property is on the element\n      if (style['object-fit'] || style['object-position']) {\n        // set the default values\n        style['object-fit'] = style['object-fit'] || 'fill';\n        fitIt(videos[index], style);\n      }\n    }\n  }\n\n  /**\n   * Object Fit\n   * @param  {object} $el Element to fit\n   * @return {object}     The element's relevant properties\n   */\n  function fitIt ($el, style) {\n    // fill is the default behavior, no action is necessary\n    if (style['object-fit'] === 'fill')\n      return;\n\n    // convenience style properties on the source element\n    var setCss = $el.style,\n        getCss = window.getComputedStyle($el);\n\n    // create and insert a wrapper element\n    var $wrap = document.createElement('object-fit');\n    $wrap.appendChild($el.parentNode.replaceChild($wrap, $el));\n\n    // style the wrapper element to mostly match the source element\n    var wrapCss = {\n      height:    '100%',\n      width:     '100%',\n      boxSizing: 'content-box',\n      display:   'inline-block',\n      overflow:  'hidden'\n    };\n\n    'backgroundColor backgroundImage borderColor borderStyle borderWidth bottom fontSize lineHeight left opacity margin position right top visibility'.replace(/\\w+/g, function (key) {\n      wrapCss[key] = getCss[key];\n    });\n\n    for (var key in wrapCss)\n      $wrap.style[key] = wrapCss[key];\n\n    // give the source element some saner styles\n    setCss.border  = setCss.margin = setCss.padding = 0;\n    setCss.display = 'block';\n    setCss.opacity = 1;\n\n    // set up the event handlers\n    $el.addEventListener('loadedmetadata', doWork);\n    window.addEventListener('optimizedResize', doWork);\n\n    // we may have missed the loadedmetadata event, so if the video has loaded\n    // enough data, just drop the event listener and execute\n    if ($el.readyState >= 1) {\n      $el.removeEventListener('loadedmetadata', doWork);\n      doWork();\n    }\n\n    /**\n     * Do the actual sizing. Math.\n     * @methodOf fitIt\n     */\n    function doWork () {\n      // the actual size and ratio of the video\n      // we do this here, even though it doesn't change, because\n      // at this point we can be sure the metadata has loaded\n      var videoWidth  = $el.videoWidth,\n          videoHeight = $el.videoHeight,\n          videoRatio  = videoWidth / videoHeight;\n\n      var wrapWidth  = $wrap.clientWidth,\n          wrapHeight = $wrap.clientHeight,\n          wrapRatio  = wrapWidth / wrapHeight;\n\n      var newHeight = 0,\n          newWidth  = 0;\n      setCss.marginLeft = setCss.marginTop = 0;\n\n      // basically we do the opposite action for contain and cover,\n      // depending on whether the video aspect ratio is less than or\n      // greater than the wrapper's aspect ratio\n      if (videoRatio < wrapRatio ?\n          style['object-fit'] === 'contain' : style['object-fit'] === 'cover') {\n        newHeight = wrapHeight * videoRatio;\n        newWidth  = wrapWidth / videoRatio;\n\n        setCss.width  = Math.round(newHeight) + 'px';\n        setCss.height = wrapHeight + 'px';\n\n        if (style['object-position-x'] === 'left')\n          setCss.marginLeft = 0;\n        else if (style['object-position-x'] === 'right')\n          setCss.marginLeft = Math.round(wrapWidth - newHeight) + 'px';\n        else\n          setCss.marginLeft = Math.round((wrapWidth - newHeight) / 2) + 'px';\n      } else {\n        newWidth = wrapWidth / videoRatio;\n\n        setCss.width     = wrapWidth + 'px';\n        setCss.height    = Math.round(newWidth) + 'px';\n\n        if (style['object-position-y'] === 'top')\n          setCss.marginTop = 0;\n        else if (style['object-position-y'] === 'bottom')\n          setCss.marginTop = Math.round(wrapHeight - newWidth) + 'px';\n        else\n          setCss.marginTop = Math.round((wrapHeight - newWidth) / 2) + 'px';\n      }\n\n      // play the video if autoplay is set\n      if ($el.autoplay)\n        $el.play();\n    }\n  }\n\n  /**\n   * Split the object-position property into x and y position properties\n   * @param  {object} style Relevant element styles\n   * @return {object}       The style object with the added x and y props\n   */\n  function parsePosition (style) {\n    if (~style['object-position'].indexOf('left'))\n      style['object-position-x'] = 'left';\n    else if (~style['object-position'].indexOf('right'))\n      style['object-position-x'] = 'right';\n    else\n      style['object-position-x'] = 'center';\n\n    if (~style['object-position'].indexOf('top'))\n      style['object-position-y'] = 'top';\n    else if (~style['object-position'].indexOf('bottom'))\n      style['object-position-y'] = 'bottom';\n    else\n      style['object-position-y'] = 'center';\n\n    return style;\n  }\n\n  /**\n   * Throttle an event with RequestAnimationFrame API for better performance\n   * @param  {string} type The event to throttle\n   * @param  {string} name Custom event name to listen for\n   * @param  {object} obj  Optional object to attach the event to\n   */\n  function throttle (type, name, obj) {\n    obj = obj || window;\n    var running = false,\n        evt     = null;\n\n    // IE does not support the CustomEvent constructor\n    // so if that fails do it the old way\n    try {\n      evt = new CustomEvent(name);\n    } catch (e) {\n      evt = document.createEvent('Event');\n      evt.initEvent(name, true, true);\n    }\n\n    var func = function () {\n      if (running) return;\n\n      running = true;\n      requestAnimationFrame(function () {\n        obj.dispatchEvent(evt);\n        running = false;\n      });\n    };\n\n    obj.addEventListener(type, func);\n  }\n};\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\n  module.exports = objectFitVideos;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export intervalometer */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return frameIntervalometer; });\n/* unused harmony export timerIntervalometer */\n/*! npm.im/intervalometer */\nfunction intervalometer(cb, request, cancel, requestParameter) {\n\tvar requestId;\n\tvar previousLoopTime;\n\tfunction loop(now) {\n\t\t// must be requested before cb() because that might call .stop()\n\t\trequestId = request(loop, requestParameter);\n\n\t\t// called with \"ms since last call\". 0 on start()\n\t\tcb(now - (previousLoopTime || now));\n\n\t\tpreviousLoopTime = now;\n\t}\n\treturn {\n\t\tstart: function start() {\n\t\t\tif (!requestId) { // prevent double starts\n\t\t\t\tloop(0);\n\t\t\t}\n\t\t},\n\t\tstop: function stop() {\n\t\t\tcancel(requestId);\n\t\t\trequestId = null;\n\t\t\tpreviousLoopTime = 0;\n\t\t}\n\t};\n}\n\nfunction frameIntervalometer(cb) {\n\treturn intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);\n}\n\nfunction timerIntervalometer(cb, delay) {\n\treturn intervalometer(cb, setTimeout, clearTimeout, delay);\n}\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('object-fit-images'), require('object-fit-videos'), require('iphone-inline-video'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.objectFitImages, global.objectFitVideos, global.iphoneInlineVideo);\n    global.index = mod.exports;\n  }\n})(this, function (exports, _objectFitImages, _objectFitVideos, _iphoneInlineVideo) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _objectFitImages2 = _interopRequireDefault(_objectFitImages);\n\n  var _objectFitVideos2 = _interopRequireDefault(_objectFitVideos);\n\n  var _iphoneInlineVideo2 = _interopRequireDefault(_iphoneInlineVideo);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var CLASS_FEATURE = '.ft-fit-bg';\n\n  /**\n   * Object fit feature class.\n   */\n\n  var ObjectFit = function (_base$features$Featur) {\n    _inherits(ObjectFit, _base$features$Featur);\n\n    function ObjectFit() {\n      _classCallCheck(this, ObjectFit);\n\n      return _possibleConstructorReturn(this, (ObjectFit.__proto__ || Object.getPrototypeOf(ObjectFit)).apply(this, arguments));\n    }\n\n    _createClass(ObjectFit, [{\n      key: 'init',\n      value: function init() {\n        var _this2 = this;\n\n        this._objectFit = this.node.getAttribute('data-object-fit');\n        this._objectPosition = this.node.getAttribute('data-object-position');\n\n        if (this._objectFit && this._objectPosition) {\n          this.node.style.objectFit = this._objectFit;\n          this.node.style.objectPosition = this._objectPosition;\n          this.node.style.fontFamily = '\"object-fit: ' + this._objectFit + '; object-position: ' + this._objectPosition + '\"';\n        } else if (this._objectFit) {\n          this.node.style.objectFit = this._objectFit;\n          this.node.style.fontFamily = '\"object-fit: ' + this._objectFit + '; object-position: ' + this.options.defaultObjectPosition + '\"';\n        } else if (this._objectPosition) {\n          this.node.style.objectPosition = this._objectPosition;\n          this.node.style.fontFamily = '\"object-fit: ' + this.options.defaultObjectFit + '; object-position: ' + this._objectPosition + '\"';\n        }\n\n        if (this.node.nodeName.toLowerCase() == 'video') {\n          (function () {\n            (0, _objectFitVideos2.default)(_this2.node);\n            (0, _iphoneInlineVideo2.default)(_this2.node, {\n              iPad: _this2.options.iPad\n            });\n\n            var onload = function onload() {\n              if (_this2.node.readyState >= _this2.node.HAVE_CURRENT_DATA) {\n                _this2.removeEventListener(_this2.node, 'loadeddata', onload);\n                _this2._removeInitialHide();\n                if (_this2.node.autoplay) _this2.node.play();\n              }\n            };\n\n            if (_this2.node.readyState >= _this2.node.HAVE_CURRENT_DATA || !_this2.options.waitForMediaLoaded) {\n              _this2._removeInitialHide();\n              if (_this2.node.autoplay) _this2.node.play();\n            } else {\n              _this2.addEventListener(_this2.node, 'loadeddata', onload);\n            }\n          })();\n        } else {\n          (0, _objectFitImages2.default)(this.node, {\n            watchMQ: this.options.watchMQ\n          });\n\n          if (this.node.naturalWidth || !this.options.waitForMediaLoaded) {\n            this._removeInitialHide();\n          } else {\n            (function () {\n              var onload = function onload() {\n                _this2.removeEventListener(_this2.node, 'load', onload);\n                _this2._removeInitialHide();\n              };\n\n              _this2.addEventListener(_this2.node, 'load', onload);\n            })();\n          }\n        }\n      }\n    }, {\n      key: '_removeInitialHide',\n      value: function _removeInitialHide() {\n        var _this3 = this;\n\n        window.setTimeout(function () {\n          if (_this3.node.parentElement.tagName.toLowerCase() === 'object-fit') {\n            _this3.node.parentElement.style.visibility = 'inherit';\n            _this3.node.parentElement.style.opacity = 'inherit';\n          }\n\n          var featureParent = _this3.node.closest(CLASS_FEATURE);\n\n          if (featureParent) {\n            featureParent.classList.remove(_this3.options.classInitialHide);\n          }\n        }, 0);\n      }\n    }]);\n\n    return ObjectFit;\n  }(base.features.Feature);\n\n  /**\n   * Default feature options (also used to initialize object-fit-images and iphone-inline-video library).\n   *\n   * @see https://github.com/bfred-it/object-fit-images\n   *\n   * @type {Object}\n   * @property {Boolean} watchMQ=false\n   *   This enables the automatic re-fix of the selected images when the window resizes.\n   *   You only need it in some cases\n   * @property {Boolean} waitForMediaLoaded=true\n   *   Enable to remove initialHideClass after media has been loaded.\n   *   Set false to wait only for polyfill initialization.\n   * @property {String} defaultObjectFit='cover'\n   *   Default object fit used when only `data-object-position` is defined\n   * @property {String} defaultObjectPosition='center center'\n   *   Default object position used when only `data-object-fit` is defined\n   */\n  ObjectFit.defaultOptions = {\n    iPad: true,\n    watchMQ: false,\n    waitForMediaLoaded: true,\n    defaultObjectFit: 'cover',\n    defaultObjectPosition: 'center center',\n    classInitialHide: '-initial-hide'\n  };\n\n  exports.default = ObjectFit;\n});\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// object-fit.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cc3bf11d057ab4eac526","/*! npm.im/iphone-inline-video 2.2.2 */\nimport { frameIntervalometer } from 'intervalometer';\n\nfunction preventEvent(element, eventName, test) {\n\tfunction handler(e) {\n\t\tif (!test || test(element, eventName)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// // console.log(eventName, 'prevented on', element);\n\t\t}\n\t}\n\telement.addEventListener(eventName, handler);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// // if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// // }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// Allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[IIVEvent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n\t\t// This should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// // console.log('Will load');\n\t}\n\n\t// // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[IIVEvent]; // Allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// // console.log('play');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\t// If it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPlay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// // console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (video.buffered.length === 0) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// // console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// // console.log('pause');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// If it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\n\t// Handle the 'ended' event only if it's not fullscreen\n\tif (video.ended && !video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVEvent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = {};\n\tvideo[IIV] = player;\n\tplayer.paused = true; // Track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = frameIntervalometer(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// // console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// Media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// // console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// // console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// Playing videos will only keep playing if no src was present when .play()â€™ed\n\t\t\tif (wasEmpty || (!hasAudio && video.autoplay)) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// Stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// Make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// Play video natively\n\t\t\tvideo[IIVPlay]();\n\t\t} else if (hasAudio && player.driver.buffered.length === 0) {\n\t\t\t// If the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// Sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// Allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// // console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction preventWithPropOrFullscreen(el) {\n\tvar isAllowed = el[IIVEvent];\n\tdelete el[IIVEvent];\n\treturn !el.webkitDisplayingFullscreen && !isAllowed;\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[IIV];\n\tvideo[IIVPlay] = video.play;\n\tvideo[IIVPause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\n\t// IIV works by seeking 60 times per second.\n\t// These events are now useless.\n\tpreventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });\n\tpreventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });\n\n\t// Limit timeupdate events\n\tpreventEvent(video, 'timeupdate', preventWithPropOrFullscreen);\n\n\t// Prevent occasional native ended events\n\tpreventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\n\nfunction enableInlineVideo(video, opts) {\n\tif ( opts === void 0 ) opts = {};\n\n\t// Stop if already enabled\n\tif (video[IIV]) {\n\t\treturn;\n\t}\n\n\t// Allow the user to skip detection\n\tif (!opts.everywhere) {\n\t\t// Only iOS8 and 9 are supported\n\t\tif (!iOS8or9) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop if it's not an allowed device\n\t\tif (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Try to pause\n\tvideo.pause();\n\n\t// Prevent autoplay.\n\t// An non-started autoplaying video can't be .pause()'d\n\tvar willAutoplay = video.autoplay;\n\tvideo.autoplay = false;\n\n\taddPlayer(video, !video.muted);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\n\t// Autoplay\n\tif (video.muted && willAutoplay) {\n\t\tvideo.play();\n\t\tvideo.addEventListener('playing', function restoreAutoplay() {\n\t\t\tvideo.autoplay = true;\n\t\t\tvideo.removeEventListener('playing', restoreAutoplay);\n\t\t});\n\t}\n\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\nexport default enableInlineVideo;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/iphone-inline-video/dist/iphone-inline-video.es-modules.js\n// module id = 0\n// module chunks = 0","/*! npm.im/object-fit-images 3.2.3 */\n'use strict';\n\nvar OFI = 'bfred-it:object-fit-images';\nvar propRegex = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\nvar testImg = typeof Image === 'undefined' ? {style: {'object-position': 1}} : new Image();\nvar supportsObjectFit = 'object-fit' in testImg.style;\nvar supportsObjectPosition = 'object-position' in testImg.style;\nvar supportsOFI = 'background-size' in testImg.style;\nvar supportsCurrentSrc = typeof testImg.currentSrc === 'string';\nvar nativeGetAttribute = testImg.getAttribute;\nvar nativeSetAttribute = testImg.setAttribute;\nvar autoModeEnabled = false;\n\nfunction createPlaceholder(w, h) {\n\treturn (\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='\" + w + \"' height='\" + h + \"'%3E%3C/svg%3E\");\n}\n\nfunction polyfillCurrentSrc(el) {\n\tif (el.srcset && !supportsCurrentSrc && window.picturefill) {\n\t\tvar pf = window.picturefill._;\n\t\t// parse srcset with picturefill where currentSrc isn't available\n\t\tif (!el[pf.ns] || !el[pf.ns].evaled) {\n\t\t\t// force synchronous srcset parsing\n\t\t\tpf.fillImg(el, {reselect: true});\n\t\t}\n\n\t\tif (!el[pf.ns].curSrc) {\n\t\t\t// force picturefill to parse srcset\n\t\t\tel[pf.ns].supported = false;\n\t\t\tpf.fillImg(el, {reselect: true});\n\t\t}\n\n\t\t// retrieve parsed currentSrc, if any\n\t\tel.currentSrc = el[pf.ns].curSrc || el.src;\n\t}\n}\n\nfunction getStyle(el) {\n\tvar style = getComputedStyle(el).fontFamily;\n\tvar parsed;\n\tvar props = {};\n\twhile ((parsed = propRegex.exec(style)) !== null) {\n\t\tprops[parsed[1]] = parsed[2];\n\t}\n\treturn props;\n}\n\nfunction setPlaceholder(img, width, height) {\n\t// Default: fill width, no height\n\tvar placeholder = createPlaceholder(width || 1, height || 0);\n\n\t// Only set placeholder if it's different\n\tif (nativeGetAttribute.call(img, 'src') !== placeholder) {\n\t\tnativeSetAttribute.call(img, 'src', placeholder);\n\t}\n}\n\nfunction onImageReady(img, callback) {\n\t// naturalWidth is only available when the image headers are loaded,\n\t// this loop will poll it every 100ms.\n\tif (img.naturalWidth) {\n\t\tcallback(img);\n\t} else {\n\t\tsetTimeout(onImageReady, 100, img, callback);\n\t}\n}\n\nfunction fixOne(el) {\n\tvar style = getStyle(el);\n\tvar ofi = el[OFI];\n\tstyle['object-fit'] = style['object-fit'] || 'fill'; // default value\n\n\t// Avoid running where unnecessary, unless OFI had already done its deed\n\tif (!ofi.img) {\n\t\t// fill is the default behavior so no action is necessary\n\t\tif (style['object-fit'] === 'fill') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Where object-fit is supported and object-position isn't (Safari < 10)\n\t\tif (\n\t\t\t!ofi.skipTest && // unless user wants to apply regardless of browser support\n\t\t\tsupportsObjectFit && // if browser already supports object-fit\n\t\t\t!style['object-position'] // unless object-position is used\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// keep a clone in memory while resetting the original to a blank\n\tif (!ofi.img) {\n\t\tofi.img = new Image(el.width, el.height);\n\t\tofi.img.srcset = nativeGetAttribute.call(el, \"data-ofi-srcset\") || el.srcset;\n\t\tofi.img.src = nativeGetAttribute.call(el, \"data-ofi-src\") || el.src;\n\n\t\t// preserve for any future cloneNode calls\n\t\t// https://github.com/bfred-it/object-fit-images/issues/53\n\t\tnativeSetAttribute.call(el, \"data-ofi-src\", el.src);\n\t\tif (el.srcset) {\n\t\t\tnativeSetAttribute.call(el, \"data-ofi-srcset\", el.srcset);\n\t\t}\n\n\t\tsetPlaceholder(el, el.naturalWidth || el.width, el.naturalHeight || el.height);\n\n\t\t// remove srcset because it overrides src\n\t\tif (el.srcset) {\n\t\t\tel.srcset = '';\n\t\t}\n\t\ttry {\n\t\t\tkeepSrcUsable(el);\n\t\t} catch (err) {\n\t\t\tif (window.console) {\n\t\t\t\tconsole.warn('https://bit.ly/ofi-old-browser');\n\t\t\t}\n\t\t}\n\t}\n\n\tpolyfillCurrentSrc(ofi.img);\n\n\tel.style.backgroundImage = \"url(\\\"\" + ((ofi.img.currentSrc || ofi.img.src).replace(/\"/g, '\\\\\"')) + \"\\\")\";\n\tel.style.backgroundPosition = style['object-position'] || 'center';\n\tel.style.backgroundRepeat = 'no-repeat';\n\tel.style.backgroundOrigin = 'content-box';\n\n\tif (/scale-down/.test(style['object-fit'])) {\n\t\tonImageReady(ofi.img, function () {\n\t\t\tif (ofi.img.naturalWidth > el.width || ofi.img.naturalHeight > el.height) {\n\t\t\t\tel.style.backgroundSize = 'contain';\n\t\t\t} else {\n\t\t\t\tel.style.backgroundSize = 'auto';\n\t\t\t}\n\t\t});\n\t} else {\n\t\tel.style.backgroundSize = style['object-fit'].replace('none', 'auto').replace('fill', '100% 100%');\n\t}\n\n\tonImageReady(ofi.img, function (img) {\n\t\tsetPlaceholder(el, img.naturalWidth, img.naturalHeight);\n\t});\n}\n\nfunction keepSrcUsable(el) {\n\tvar descriptors = {\n\t\tget: function get(prop) {\n\t\t\treturn el[OFI].img[prop ? prop : 'src'];\n\t\t},\n\t\tset: function set(value, prop) {\n\t\t\tel[OFI].img[prop ? prop : 'src'] = value;\n\t\t\tnativeSetAttribute.call(el, (\"data-ofi-\" + prop), value); // preserve for any future cloneNode\n\t\t\tfixOne(el);\n\t\t\treturn value;\n\t\t}\n\t};\n\tObject.defineProperty(el, 'src', descriptors);\n\tObject.defineProperty(el, 'currentSrc', {\n\t\tget: function () { return descriptors.get('currentSrc'); }\n\t});\n\tObject.defineProperty(el, 'srcset', {\n\t\tget: function () { return descriptors.get('srcset'); },\n\t\tset: function (ss) { return descriptors.set(ss, 'srcset'); }\n\t});\n}\n\nfunction hijackAttributes() {\n\tfunction getOfiImageMaybe(el, name) {\n\t\treturn el[OFI] && el[OFI].img && (name === 'src' || name === 'srcset') ? el[OFI].img : el;\n\t}\n\tif (!supportsObjectPosition) {\n\t\tHTMLImageElement.prototype.getAttribute = function (name) {\n\t\t\treturn nativeGetAttribute.call(getOfiImageMaybe(this, name), name);\n\t\t};\n\n\t\tHTMLImageElement.prototype.setAttribute = function (name, value) {\n\t\t\treturn nativeSetAttribute.call(getOfiImageMaybe(this, name), name, String(value));\n\t\t};\n\t}\n}\n\nfunction fix(imgs, opts) {\n\tvar startAutoMode = !autoModeEnabled && !imgs;\n\topts = opts || {};\n\timgs = imgs || 'img';\n\n\tif ((supportsObjectPosition && !opts.skipTest) || !supportsOFI) {\n\t\treturn false;\n\t}\n\n\t// use imgs as a selector or just select all images\n\tif (imgs === 'img') {\n\t\timgs = document.getElementsByTagName('img');\n\t} else if (typeof imgs === 'string') {\n\t\timgs = document.querySelectorAll(imgs);\n\t} else if (!('length' in imgs)) {\n\t\timgs = [imgs];\n\t}\n\n\t// apply fix to all\n\tfor (var i = 0; i < imgs.length; i++) {\n\t\timgs[i][OFI] = imgs[i][OFI] || {\n\t\t\tskipTest: opts.skipTest\n\t\t};\n\t\tfixOne(imgs[i]);\n\t}\n\n\tif (startAutoMode) {\n\t\tdocument.body.addEventListener('load', function (e) {\n\t\t\tif (e.target.tagName === 'IMG') {\n\t\t\t\tfix(e.target, {\n\t\t\t\t\tskipTest: opts.skipTest\n\t\t\t\t});\n\t\t\t}\n\t\t}, true);\n\t\tautoModeEnabled = true;\n\t\timgs = 'img'; // reset to a generic selector for watchMQ\n\t}\n\n\t// if requested, watch media queries for object-fit change\n\tif (opts.watchMQ) {\n\t\twindow.addEventListener('resize', fix.bind(null, imgs, {\n\t\t\tskipTest: opts.skipTest\n\t\t}));\n\t}\n}\n\nfix.supportsObjectFit = supportsObjectFit;\nfix.supportsObjectPosition = supportsObjectPosition;\n\nhijackAttributes();\n\nmodule.exports = fix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-fit-images/dist/ofi.common-js.js\n// module id = 1\n// module chunks = 0","/**\n * Object Fit Videos\n * Polyfill for object-fit and object-position CSS properties on video elements\n * Covers IE9, IE10, IE11, Edge, Safari <10\n *\n * Usage\n * In your CSS, add a special font-family tag for IE/Edge\n * video {\n *   object-fit: cover;\n *   font-family: 'object-fit: cover;';\n * }\n *\n * Before the closing body tag, or whenever the DOM is ready,\n * make the JavaScript call\n * objectFitVideos();\n *\n * All video elements with the special CSS property will be targeted\n *\n * @license  MIT (https://opensource.org/licenses/MIT)\n * @author   Todd Miller <todd.miller@tricomb2b.com>\n * @version  1.0.2\n * @changelog\n * 2016-08-19 - Adds object-position support.\n * 2016-08-19 - Add throttle function for more performant resize events\n * 2016-08-19 - Initial release with object-fit support, and\n *              object-position default 'center'\n * 2016-10-14 - No longer relies on window load event, instead requires a specific\n *              function call to initialize the videos for object fit and position.\n * 2016-11-28 - Support CommonJS environment, courtesy of @msorensson\n * 2016-12-05 - Refactors the throttling function to support IE\n * 2017-09-26 - Fix an issue with autplay not working on polyfilled videos\n *            - Adds the capability to specify elements to polyfill,\n *              instead of just checking every video element for the\n *              CSS property. Slight performance gain in most usecases,\n *              and a bigger gain in a few usecases.\n * 2017-10-24 - Add user agent check to enable polyfill for all Edge browsers.\n *              object-fit is supported on Edge >= 16, but currently just for images.\n */\nvar objectFitVideos = function (videos) {\n  'use strict';\n\n  var isEdge = navigator.userAgent.indexOf('Edge/') >= 0;\n\n  var testImg                = new Image(),\n      supportsObjectFit      = 'object-fit' in testImg.style && !isEdge,\n      supportsObjectPosition = 'object-position' in testImg.style && !isEdge,\n      propRegex              = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\n\n  if (!supportsObjectFit || !supportsObjectPosition) {\n    initialize(videos);\n    throttle('resize', 'optimizedResize');\n  }\n\n  /**\n   * Parse the style and look for the special font-family tag\n   * @param  {object} $el The element to parse\n   * @return {object}     The font-family properties we're interested in\n   */\n  function getStyle ($el) {\n    var style  = getComputedStyle($el).fontFamily,\n        parsed = null,\n        props  = {};\n\n      while ((parsed = propRegex.exec(style)) !== null) {\n        props[parsed[1]] = parsed[2];\n      }\n\n      if (props['object-position'])\n        return parsePosition(props);\n\n      return props;\n  }\n\n  /**\n   * Initialize all the relevant video elements and get them fitted\n   */\n  function initialize (videos) {\n    var index = -1;\n\n    if (!videos) {\n      // if no videos given, query all video elements\n      videos = document.querySelectorAll('video');\n    } else if (!('length' in videos)) {\n      // convert to an array for proper looping if an array or NodeList\n      // was not given\n      videos = [videos];\n    }\n\n    while (videos[++index]) {\n      var style = getStyle(videos[index]);\n\n      // only do work if the property is on the element\n      if (style['object-fit'] || style['object-position']) {\n        // set the default values\n        style['object-fit'] = style['object-fit'] || 'fill';\n        fitIt(videos[index], style);\n      }\n    }\n  }\n\n  /**\n   * Object Fit\n   * @param  {object} $el Element to fit\n   * @return {object}     The element's relevant properties\n   */\n  function fitIt ($el, style) {\n    // fill is the default behavior, no action is necessary\n    if (style['object-fit'] === 'fill')\n      return;\n\n    // convenience style properties on the source element\n    var setCss = $el.style,\n        getCss = window.getComputedStyle($el);\n\n    // create and insert a wrapper element\n    var $wrap = document.createElement('object-fit');\n    $wrap.appendChild($el.parentNode.replaceChild($wrap, $el));\n\n    // style the wrapper element to mostly match the source element\n    var wrapCss = {\n      height:    '100%',\n      width:     '100%',\n      boxSizing: 'content-box',\n      display:   'inline-block',\n      overflow:  'hidden'\n    };\n\n    'backgroundColor backgroundImage borderColor borderStyle borderWidth bottom fontSize lineHeight left opacity margin position right top visibility'.replace(/\\w+/g, function (key) {\n      wrapCss[key] = getCss[key];\n    });\n\n    for (var key in wrapCss)\n      $wrap.style[key] = wrapCss[key];\n\n    // give the source element some saner styles\n    setCss.border  = setCss.margin = setCss.padding = 0;\n    setCss.display = 'block';\n    setCss.opacity = 1;\n\n    // set up the event handlers\n    $el.addEventListener('loadedmetadata', doWork);\n    window.addEventListener('optimizedResize', doWork);\n\n    // we may have missed the loadedmetadata event, so if the video has loaded\n    // enough data, just drop the event listener and execute\n    if ($el.readyState >= 1) {\n      $el.removeEventListener('loadedmetadata', doWork);\n      doWork();\n    }\n\n    /**\n     * Do the actual sizing. Math.\n     * @methodOf fitIt\n     */\n    function doWork () {\n      // the actual size and ratio of the video\n      // we do this here, even though it doesn't change, because\n      // at this point we can be sure the metadata has loaded\n      var videoWidth  = $el.videoWidth,\n          videoHeight = $el.videoHeight,\n          videoRatio  = videoWidth / videoHeight;\n\n      var wrapWidth  = $wrap.clientWidth,\n          wrapHeight = $wrap.clientHeight,\n          wrapRatio  = wrapWidth / wrapHeight;\n\n      var newHeight = 0,\n          newWidth  = 0;\n      setCss.marginLeft = setCss.marginTop = 0;\n\n      // basically we do the opposite action for contain and cover,\n      // depending on whether the video aspect ratio is less than or\n      // greater than the wrapper's aspect ratio\n      if (videoRatio < wrapRatio ?\n          style['object-fit'] === 'contain' : style['object-fit'] === 'cover') {\n        newHeight = wrapHeight * videoRatio;\n        newWidth  = wrapWidth / videoRatio;\n\n        setCss.width  = Math.round(newHeight) + 'px';\n        setCss.height = wrapHeight + 'px';\n\n        if (style['object-position-x'] === 'left')\n          setCss.marginLeft = 0;\n        else if (style['object-position-x'] === 'right')\n          setCss.marginLeft = Math.round(wrapWidth - newHeight) + 'px';\n        else\n          setCss.marginLeft = Math.round((wrapWidth - newHeight) / 2) + 'px';\n      } else {\n        newWidth = wrapWidth / videoRatio;\n\n        setCss.width     = wrapWidth + 'px';\n        setCss.height    = Math.round(newWidth) + 'px';\n\n        if (style['object-position-y'] === 'top')\n          setCss.marginTop = 0;\n        else if (style['object-position-y'] === 'bottom')\n          setCss.marginTop = Math.round(wrapHeight - newWidth) + 'px';\n        else\n          setCss.marginTop = Math.round((wrapHeight - newWidth) / 2) + 'px';\n      }\n\n      // play the video if autoplay is set\n      if ($el.autoplay)\n        $el.play();\n    }\n  }\n\n  /**\n   * Split the object-position property into x and y position properties\n   * @param  {object} style Relevant element styles\n   * @return {object}       The style object with the added x and y props\n   */\n  function parsePosition (style) {\n    if (~style['object-position'].indexOf('left'))\n      style['object-position-x'] = 'left';\n    else if (~style['object-position'].indexOf('right'))\n      style['object-position-x'] = 'right';\n    else\n      style['object-position-x'] = 'center';\n\n    if (~style['object-position'].indexOf('top'))\n      style['object-position-y'] = 'top';\n    else if (~style['object-position'].indexOf('bottom'))\n      style['object-position-y'] = 'bottom';\n    else\n      style['object-position-y'] = 'center';\n\n    return style;\n  }\n\n  /**\n   * Throttle an event with RequestAnimationFrame API for better performance\n   * @param  {string} type The event to throttle\n   * @param  {string} name Custom event name to listen for\n   * @param  {object} obj  Optional object to attach the event to\n   */\n  function throttle (type, name, obj) {\n    obj = obj || window;\n    var running = false,\n        evt     = null;\n\n    // IE does not support the CustomEvent constructor\n    // so if that fails do it the old way\n    try {\n      evt = new CustomEvent(name);\n    } catch (e) {\n      evt = document.createEvent('Event');\n      evt.initEvent(name, true, true);\n    }\n\n    var func = function () {\n      if (running) return;\n\n      running = true;\n      requestAnimationFrame(function () {\n        obj.dispatchEvent(evt);\n        running = false;\n      });\n    };\n\n    obj.addEventListener(type, func);\n  }\n};\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\n  module.exports = objectFitVideos;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-fit-videos/object-fit-videos.js\n// module id = 2\n// module chunks = 0","/*! npm.im/intervalometer */\nfunction intervalometer(cb, request, cancel, requestParameter) {\n\tvar requestId;\n\tvar previousLoopTime;\n\tfunction loop(now) {\n\t\t// must be requested before cb() because that might call .stop()\n\t\trequestId = request(loop, requestParameter);\n\n\t\t// called with \"ms since last call\". 0 on start()\n\t\tcb(now - (previousLoopTime || now));\n\n\t\tpreviousLoopTime = now;\n\t}\n\treturn {\n\t\tstart: function start() {\n\t\t\tif (!requestId) { // prevent double starts\n\t\t\t\tloop(0);\n\t\t\t}\n\t\t},\n\t\tstop: function stop() {\n\t\t\tcancel(requestId);\n\t\t\trequestId = null;\n\t\t\tpreviousLoopTime = 0;\n\t\t}\n\t};\n}\n\nfunction frameIntervalometer(cb) {\n\treturn intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);\n}\n\nfunction timerIntervalometer(cb, delay) {\n\treturn intervalometer(cb, setTimeout, clearTimeout, delay);\n}\n\nexport { intervalometer, frameIntervalometer, timerIntervalometer };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/intervalometer/dist/intervalometer.es-modules.js\n// module id = 3\n// module chunks = 0","import objectFitImage from 'object-fit-images'\nimport objectFitVideo from 'object-fit-videos'\nimport enableInlineVideo from 'iphone-inline-video'\n\nconst CLASS_FEATURE = '.ft-fit-bg'\n\n/**\n * Object fit feature class.\n */\nclass ObjectFit extends base.features.Feature {\n\n  init() {\n    this._objectFit = this.node.getAttribute('data-object-fit')\n    this._objectPosition = this.node.getAttribute('data-object-position')\n\n    if (this._objectFit && this._objectPosition) {\n      this.node.style.objectFit = this._objectFit\n      this.node.style.objectPosition = this._objectPosition\n      this.node.style.fontFamily = `\"object-fit: ${this._objectFit}; object-position: ${this._objectPosition}\"`\n    } else if (this._objectFit) {\n      this.node.style.objectFit = this._objectFit\n      this.node.style.fontFamily = `\"object-fit: ${this._objectFit}; object-position: ${this.options.defaultObjectPosition}\"`\n    } else  if (this._objectPosition) {\n      this.node.style.objectPosition = this._objectPosition\n      this.node.style.fontFamily = `\"object-fit: ${this.options.defaultObjectFit}; object-position: ${this._objectPosition}\"`\n    }\n\n    if (this.node.nodeName.toLowerCase() == 'video') {\n      objectFitVideo(this.node)\n      enableInlineVideo(this.node, {\n          iPad: this.options.iPad\n      })\n\n      let onload = () => {\n        if (this.node.readyState >= this.node.HAVE_CURRENT_DATA) {\n          this.removeEventListener(this.node, 'loadeddata', onload)\n          this._removeInitialHide()\n          if (this.node.autoplay) this.node.play()\n        }\n      }\n\n      if (this.node.readyState >= this.node.HAVE_CURRENT_DATA || !this.options.waitForMediaLoaded) {\n        this._removeInitialHide()\n        if (this.node.autoplay) this.node.play()\n      } else {\n        this.addEventListener(this.node, 'loadeddata', onload)\n      }\n    } else {\n      objectFitImage(this.node, {\n        watchMQ: this.options.watchMQ\n      })\n\n      if (this.node.naturalWidth || !this.options.waitForMediaLoaded) {\n        this._removeInitialHide()\n      } else {\n        let onload = () => {\n          this.removeEventListener(this.node, 'load', onload)\n          this._removeInitialHide()\n        }\n\n        this.addEventListener(this.node, 'load', onload)\n      }\n    }\n  }\n\n  _removeInitialHide() {\n    window.setTimeout(() => {\n      if (this.node.parentElement.tagName.toLowerCase() === 'object-fit') {\n        this.node.parentElement.style.visibility = 'inherit'\n        this.node.parentElement.style.opacity = 'inherit'\n      }\n\n      let featureParent = this.node.closest(CLASS_FEATURE)\n\n      if (featureParent) {\n        featureParent.classList.remove(this.options.classInitialHide)\n      }\n    }, 0)\n  }\n\n}\n\n/**\n * Default feature options (also used to initialize object-fit-images and iphone-inline-video library).\n *\n * @see https://github.com/bfred-it/object-fit-images\n *\n * @type {Object}\n * @property {Boolean} watchMQ=false\n *   This enables the automatic re-fix of the selected images when the window resizes.\n *   You only need it in some cases\n * @property {Boolean} waitForMediaLoaded=true\n *   Enable to remove initialHideClass after media has been loaded.\n *   Set false to wait only for polyfill initialization.\n * @property {String} defaultObjectFit='cover'\n *   Default object fit used when only `data-object-position` is defined\n * @property {String} defaultObjectPosition='center center'\n *   Default object position used when only `data-object-fit` is defined\n */\nObjectFit.defaultOptions = {\n  iPad: true,\n  watchMQ: false,\n  waitForMediaLoaded: true,\n  defaultObjectFit: 'cover',\n  defaultObjectPosition: 'center center',\n  classInitialHide: '-initial-hide'\n}\n\nexport default ObjectFit\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}